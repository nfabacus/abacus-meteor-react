{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","extends","typeof","toConsumableArray","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"qs","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Qs"}]},{"source":"path-to-regexp","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"PathToRegexp"}]},{"source":"parseurl","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"ParseUrl"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/kadira:flow-router-ssr/client/router.js","filenameRelative":"/packages/kadira:flow-router-ssr/client/router.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/kadira:flow-router-ssr/client/router.js.map","sourceFileName":"/packages/kadira:flow-router-ssr/client/router.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"router"},"ignored":false,"code":"var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _qs = require('qs');\n\nvar _qs2 = _interopRequireDefault(_qs);\n\nvar _pathToRegexp = require('path-to-regexp');\n\nvar _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);\n\nvar _parseurl = require('parseurl');\n\nvar _parseurl2 = _interopRequireDefault(_parseurl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar logger = console; /* eslint new-cap: 0, no-loop-func: 0, prefer-arrow-callback: 0 */\n\n\nRouter = function (_SharedRouter) {\n  (0, _inherits3['default'])(Router, _SharedRouter);\n\n  function Router() {\n    (0, _classCallCheck3['default'])(this, Router);\n\n\n    // holds the current context\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, _SharedRouter.call(this));\n\n    _this._current = {};\n\n    // tracks the current path change\n    _this._onEveryPath = new Tracker.Dependency();\n    _this._params = new ReactiveDict();\n    _this._queryParams = new ReactiveDict();\n\n    // if _askedToWait is true. We don't automatically start the router\n    // in Meteor.startup callback. (see client/_init.js)\n    // Instead user need to call `.initialize()\n    _this._askedToWait = false;\n    _this._initialized = false;\n\n    _this._triggersEnter = [];\n    _this._triggersExit = [];\n\n    // Meteor exposes to the client the path prefix that was defined using the\n    // ROOT_URL environement variable on the server using the global runtime\n    // configuration. See #315.\n    _this._basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n\n    _this.env.replaceState = new Meteor.EnvironmentVariable();\n    _this.env.reload = new Meteor.EnvironmentVariable();\n    _this.env.inAction = new Meteor.EnvironmentVariable();\n    _this.env.inPopstate = new Meteor.EnvironmentVariable();\n\n    // this holds route pathDefs\n    _this._routeDefs = [];\n\n    _this._initTriggersAPI();\n    _this._initClickAnchorHandlers();\n    return _this;\n  }\n\n  Router.prototype.initialize = function () {\n    function initialize(options) {\n      options = options || {};\n\n      if (this._initialized) {\n        throw new Error('FlowRouter is already initialized');\n      }\n\n      this._initialized = true;\n      var path = location.pathname + location.search + (location.hash || '');\n      this._initiateHandlingBackButton();\n      this.go(path);\n    }\n\n    return initialize;\n  }();\n\n  Router.prototype.wait = function () {\n    function wait() {\n      if (this._initialized) {\n        throw new Error(\"can't wait after FlowRouter has been initialized\");\n      }\n\n      this._askedToWait = true;\n    }\n\n    return wait;\n  }();\n\n  Router.prototype.reload = function () {\n    function reload() {\n      var _this2 = this;\n\n      this.env.reload.withValue(true, function () {\n        _this2.go(_this2._current.path);\n      });\n    }\n\n    return reload;\n  }();\n\n  Router.prototype.setParams = function () {\n    function setParams(newParams) {\n      if (!this._current.route) {\n        return false;\n      }\n\n      var pathDef = this._current.route.pathDef;\n      var existingParams = this._current.params;\n\n      var params = (0, _extends3['default'])({}, existingParams, newParams);\n\n      for (var k in meteorBabelHelpers.sanitizeForInObject(params)) {\n        if (params[k] === null || params[k] === undefined) {\n          delete params[k];\n        }\n      }\n\n      var queryParams = this._current.queryParams;\n\n      this.go(pathDef, params, queryParams);\n      return true;\n    }\n\n    return setParams;\n  }();\n\n  Router.prototype.setQueryParams = function () {\n    function setQueryParams(newParams) {\n      if (!this._current.route) {\n        return false;\n      }\n\n      var queryParams = (0, _extends3['default'])({}, this._current.queryParams, newParams);\n\n      for (var k in meteorBabelHelpers.sanitizeForInObject(queryParams)) {\n        if (queryParams[k] === null || queryParams[k] === undefined) {\n          delete queryParams[k];\n        }\n      }\n\n      var pathDef = this._current.route.pathDef;\n      var params = this._current.params;\n      this.go(pathDef, params, queryParams);\n      return true;\n    }\n\n    return setQueryParams;\n  }();\n\n  Router.prototype.withReplaceState = function () {\n    function withReplaceState(fn) {\n      return this.env.replaceState.withValue(true, fn);\n    }\n\n    return withReplaceState;\n  }();\n\n  Router.prototype.watchPathChange = function () {\n    function watchPathChange() {\n      this._onEveryPath.depend();\n    }\n\n    return watchPathChange;\n  }();\n\n  Router.prototype.getParam = function () {\n    function getParam(key) {\n      // We update this._params reactive store only after we Tracker.afterFlush\n      // event to make sure, older routes does not get the updated value even\n      // before the new UI is rendered.\n      //\n      // But, then it cause issues for the new route(in the action)\n      // where if picks up older data.\n      //\n      // That's why we directly get values from the context when called\n      // inside an action.\n      var value = this._params.get(key);\n      if (this.env.inAction.get()) {\n        return this._current.params[key];\n      }\n\n      return value;\n    }\n\n    return getParam;\n  }();\n\n  Router.prototype.getQueryParam = function () {\n    function getQueryParam(key) {\n      // See above .getParam() for more information.\n      var value = this._queryParams.get(key);\n      if (this.env.inAction.get()) {\n        return this._current.queryParams[key];\n      }\n\n      return value;\n    }\n\n    return getQueryParam;\n  }();\n\n  Router.prototype.getRouteName = function () {\n    function getRouteName() {\n      this.watchPathChange();\n      return this._current.route.name;\n    }\n\n    return getRouteName;\n  }();\n\n  Router.prototype.route = function () {\n    function route(pathDef, options, group) {\n      var currentRoute = _SharedRouter.prototype.route.call(this, pathDef, options, group);\n      var keys = [];\n      var regexp = (0, _pathToRegexp2['default'])(pathDef, keys);\n      this._routeDefs.push({ regexp: regexp, keys: keys, pathDef: pathDef, route: currentRoute });\n\n      return currentRoute;\n    }\n\n    return route;\n  }();\n\n  Router.prototype.go = function () {\n    function go(pathDef, fields, queryParams) {\n      var _this3 = this;\n\n      var path = this.path(pathDef, fields, queryParams);\n\n      if (!path) {\n        logger.error('Path is required for FlowRouter.go()');\n        return;\n      }\n\n      var context = this._buildContext(path);\n\n      // Implement idempotant routing\n      var insideAReload = this.env.reload.get();\n      if (this._current.path === path && !insideAReload) {\n        return;\n      }\n\n      var allQueryParams = this._decodeValues(_qs2['default'].parse(context.queryString));\n\n      // Remove basePath from the path\n      var pathname = context.pathname;\n      if (this._basePath) {\n        var cleanedBasePath = this._basePath.trim().replace(/^\\//, '').replace(/$\\//, '');\n        pathname = context.pathname.replace('/' + cleanedBasePath, '');\n      }\n\n      var _loop = function () {\n        function _loop(lc) {\n          var routeDef = _this3._routeDefs[lc];\n          var matched = routeDef.regexp.exec(pathname);\n          if (matched) {\n            var _ret2 = function () {\n              var params = {};\n              routeDef.keys.forEach(function (_ref, index) {\n                var name = _ref.name;\n\n                var match = matched[index + 1];\n                params[name] = typeof match !== 'undefined' ? decodeURIComponent(match) : match;\n              });\n\n              var matchedContext = (0, _extends3['default'])({}, context, {\n                params: params,\n                queryParams: allQueryParams,\n                route: routeDef.route\n              });\n\n              _this3._navigate(matchedContext);\n              return {\n                v: {\n                  v: void 0\n                }\n              };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : (0, _typeof3['default'])(_ret2)) === \"object\") return _ret2.v;\n          }\n        }\n\n        return _loop;\n      }();\n\n      for (var lc = 0; lc < this._routeDefs.length; lc++) {\n        var _ret = _loop(lc);\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3['default'])(_ret)) === \"object\") return _ret.v;\n      }\n\n      var notFoundRoute = this._getNotFoundRoute();\n      var notFoundContext = (0, _extends3['default'])({}, context, {\n        route: notFoundRoute,\n        params: {},\n        queryParams: allQueryParams\n      });\n      this._navigate(notFoundContext);\n    }\n\n    return go;\n  }();\n\n  Router.prototype._navigate = function () {\n    function _navigate(context) {\n      var triggersEnter = [].concat((0, _toConsumableArray3['default'])(this._triggersEnter), (0, _toConsumableArray3['default'])(context.route._triggersEnter));\n      var redirectArgs = this._runTriggers(triggersEnter, context);\n\n      if (redirectArgs) {\n        return this.go.apply(this, (0, _toConsumableArray3['default'])(redirectArgs));\n      }\n\n      // Set the current context\n      var oldContext = this._current;\n      this._current = context;\n\n      // Run exit handlers\n      if (oldContext && oldContext.route) {\n        var triggersExit = [].concat((0, _toConsumableArray3['default'])(this._triggersExit), (0, _toConsumableArray3['default'])(oldContext.route._triggersExit));\n        var exitRedirectArgs = this._runTriggers(triggersExit, oldContext);\n\n        if (exitRedirectArgs) {\n          return this.go.apply(this, (0, _toConsumableArray3['default'])(exitRedirectArgs));\n        }\n      }\n\n      // If we are inside a popstate event,\n      // we should not change the history\n      if (!this.env.inPopstate.get()) {\n        var useReplaceState = this.env.replaceState.get();\n        var path = context.path;\n        var params = context.params;\n        var queryParams = context.queryParams;\n\n        var urlState = { path: path, params: params, queryParams: queryParams };\n        if (useReplaceState) {\n          history.replaceState(urlState, window.title, path);\n        } else {\n          history.pushState(urlState, window.title, path);\n        }\n      }\n\n      this._applyRoute();\n    }\n\n    return _navigate;\n  }();\n\n  Router.prototype._applyRoute = function () {\n    function _applyRoute() {\n      var _this4 = this;\n\n      var currentContext = this._current;\n      var route = currentContext.route;\n\n      // otherwise, computations inside action will trigger to re-run\n      // this computation. which we do not need.\n      Tracker.nonreactive(function () {\n        _this4.env.inAction.withValue(true, function () {\n          route.callAction(currentContext);\n        });\n\n        Tracker.afterFlush(function () {\n          _this4._onEveryPath.changed();\n          _this4._updateReactiveDict(_this4._params, currentContext.params);\n          _this4._updateReactiveDict(_this4._queryParams, currentContext.queryParams);\n        });\n      });\n    }\n\n    return _applyRoute;\n  }();\n\n  Router.prototype._getNotFoundRoute = function () {\n    function _getNotFoundRoute() {\n      var notFoundOptions = this.notFound || {\n        action: function () {\n          function action() {\n            var current = FlowRouter.current();\n            logger.error('There is no route for the path:', current.path);\n          }\n\n          return action;\n        }()\n      };\n\n      return new Route(this, '*', notFoundOptions);\n    }\n\n    return _getNotFoundRoute;\n  }();\n\n  Router.prototype._runTriggers = function () {\n    function _runTriggers(triggers, context) {\n      var redirectArgs = void 0;\n      var redirectFn = function () {\n        function redirectFn(url, params, queryParams) {\n          if (/^http(s)?:\\/\\//.test(url)) {\n            var message = '\\n          Redirects to URLs outside of the app are not supported\\n          in this version of Flow Router.\\n          Use \\'window.location = yourUrl\\' instead.\\n        ';\n            throw new Error(message);\n          }\n          redirectArgs = [url, params, queryParams];\n        }\n\n        return redirectFn;\n      }();\n\n      Triggers.runTriggers(triggers, context, redirectFn, function () {});\n\n      return redirectArgs;\n    }\n\n    return _runTriggers;\n  }();\n\n  Router.prototype._decodeValues = function () {\n    function _decodeValues(obj) {\n      var newObj = {};\n      Object.keys(obj).forEach(function (key) {\n        var value = obj[key];\n        newObj[key] = typeof value !== 'undefined' ? decodeURIComponent(value) : value;\n      });\n\n      return newObj;\n    }\n\n    return _decodeValues;\n  }();\n\n  Router.prototype._updateReactiveDict = function () {\n    function _updateReactiveDict(dict, newValues) {\n      var currentKeys = _.keys(newValues);\n      var oldKeys = _.keys(dict.keyDeps);\n\n      // set new values\n      currentKeys.forEach(function (key) {\n        dict.set(key, newValues[key]);\n      });\n\n      // remove keys which does not exisits here\n      var removedKeys = _.difference(oldKeys, currentKeys);\n      removedKeys.forEach(function (key) {\n        dict.set(key, undefined);\n      });\n    }\n\n    return _updateReactiveDict;\n  }();\n\n  Router.prototype._initTriggersAPI = function () {\n    function _initTriggersAPI() {\n      var _this5 = this;\n\n      this.triggers = {\n        enter: function () {\n          function enter(triggers, filter) {\n            triggers = Triggers.applyFilters(triggers, filter);\n            if (triggers.length) {\n              _this5._triggersEnter = _this5._triggersEnter.concat(triggers);\n            }\n          }\n\n          return enter;\n        }(),\n\n        exit: function () {\n          function exit(triggers, filter) {\n            triggers = Triggers.applyFilters(triggers, filter);\n            if (triggers.length) {\n              _this5._triggersExit = _this5._triggersExit.concat(triggers);\n            }\n          }\n\n          return exit;\n        }()\n      };\n    }\n\n    return _initTriggersAPI;\n  }();\n\n  // This is required for implementing a router class.\n\n\n  Router.prototype._getCurrentRouteContext = function () {\n    function _getCurrentRouteContext() {\n      return this._current;\n    }\n\n    return _getCurrentRouteContext;\n  }();\n\n  Router.prototype._initClickAnchorHandlers = function () {\n    function _initClickAnchorHandlers() {\n      // This logic is taken from page.js\n      // See: https://github.com/visionmedia/page.js\n      var self = this;\n      var clickEvent = typeof document !== 'undefined' && document.ontouchstart ? 'touchstart' : 'click';\n      document.addEventListener(clickEvent, onclick, false);\n\n      function onclick(e) {\n        if (which(e) !== 1) {\n          return;\n        }\n\n        if (e.metaKey || e.ctrlKey || e.shiftKey) {\n          return;\n        }\n\n        if (e.defaultPrevented) {\n          return;\n        }\n\n        // ensure link\n        // use shadow dom when available\n        var el = e.path ? e.path[0] : e.target;\n        while (el && el.nodeName !== 'A') {\n          el = el.parentNode;\n        }\n\n        if (!el || el.nodeName !== 'A') {\n          return;\n        }\n\n        // Ignore if tag has\n        // 1. \"download\" attribute\n        // 2. rel=\"external\" attribute\n        if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') {\n          return;\n        }\n\n        // ensure non-hash for the same path\n        var link = el.getAttribute('href');\n        if (el.pathname === location.pathname && (el.hash || link === '#')) {\n          return;\n        }\n\n        // Check for mailto: in the href\n        if (link && link.indexOf('mailto:') > -1) {\n          return;\n        }\n\n        // check target\n        if (el.target) {\n          return;\n        }\n\n        // x-origin\n        if (!sameOrigin(el.href)) {\n          return;\n        }\n\n        // rebuild path\n        var path = el.pathname + el.search + (el.hash || '');\n\n        // strip leading \"/[drive letter]:\" on NW.js on Windows\n        if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n          path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n        }\n\n        e.preventDefault();\n        self.go(path);\n      }\n\n      function which(e) {\n        e = e || window.event;\n        return e.which === null ? e.button : e.which;\n      }\n\n      function sameOrigin(href) {\n        var origin = location.protocol + '//' + location.hostname;\n        if (location.port) {\n          origin += ':' + location.port;\n        }\n\n        return href && href.indexOf(origin) === 0;\n      }\n    }\n\n    return _initClickAnchorHandlers;\n  }();\n\n  Router.prototype._initiateHandlingBackButton = function () {\n    function _initiateHandlingBackButton() {\n      var self = this;\n      window.addEventListener('popstate', onpopstate, false);\n\n      function onpopstate() {\n        // In some browsers they fire popstate event right after page has loaded.\n        // That's not the correct way for the popstate.\n        // Normally, we need to handle it.\n        // But, we don't want to do it since self.go() is already idempotent.\n        var path = location.pathname + location.search + (location.hash || '');\n        self.env.inPopstate.withValue(true, function () {\n          self.go(path);\n        });\n      }\n    }\n\n    return _initiateHandlingBackButton;\n  }();\n\n  Router.prototype._buildContext = function () {\n    function _buildContext(path) {\n      var parsedUrl = (0, _parseurl2['default'])({ url: path });\n\n      var context = {\n        path: path,\n        pathname: parsedUrl.pathname,\n        hash: parsedUrl.hash ? parsedUrl.hash.substr(1) : null,\n        queryString: parsedUrl.search ? parsedUrl.search.substr(1) : null\n      };\n\n      return context;\n    }\n\n    return _buildContext;\n  }();\n\n  return Router;\n}(SharedRouter);","ast":null,"map":{"version":3,"sources":["/packages/kadira:flow-router-ssr/client/router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;AACA;;;;AACA;;;;;;AACA,IAAM,SAAS,OAAT;;;AAEN;;;AACE,oBAAc;;;;;;kEACZ,0BADY;;AAIZ,UAAK,QAAL,GAAgB,EAAhB;;;AAJY,SAOZ,CAAK,YAAL,GAAoB,IAAI,QAAQ,UAAR,EAAxB,CAPY;AAQZ,UAAK,OAAL,GAAe,IAAI,YAAJ,EAAf,CARY;AASZ,UAAK,YAAL,GAAoB,IAAI,YAAJ,EAApB;;;;;AATY,SAcZ,CAAK,YAAL,GAAoB,KAApB,CAdY;AAeZ,UAAK,YAAL,GAAoB,KAApB,CAfY;;AAiBZ,UAAK,cAAL,GAAsB,EAAtB,CAjBY;AAkBZ,UAAK,aAAL,GAAqB,EAArB;;;;;AAlBY,SAuBZ,CAAK,SAAL,GAAiB,0BAA0B,oBAA1B,IAAkD,EAAlD,CAvBL;;AAyBZ,UAAK,GAAL,CAAS,YAAT,GAAwB,IAAI,OAAO,mBAAP,EAA5B,CAzBY;AA0BZ,UAAK,GAAL,CAAS,MAAT,GAAkB,IAAI,OAAO,mBAAP,EAAtB,CA1BY;AA2BZ,UAAK,GAAL,CAAS,QAAT,GAAoB,IAAI,OAAO,mBAAP,EAAxB,CA3BY;AA4BZ,UAAK,GAAL,CAAS,UAAT,GAAsB,IAAI,OAAO,mBAAP,EAA1B;;;AA5BY,SA+BZ,CAAK,UAAL,GAAkB,EAAlB,CA/BY;;AAiCZ,UAAK,gBAAL,GAjCY;AAkCZ,UAAK,wBAAL,GAlCY;;GAAd;;mBAqCA;wBAAW,SAAS;AAClB,gBAAU,WAAW,EAAX,CADQ;;AAGlB,UAAI,KAAK,YAAL,EAAmB;AACrB,cAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN,CADqB;OAAvB;;AAIA,WAAK,YAAL,GAAoB,IAApB,CAPkB;AAQlB,UAAM,OAAO,SAAS,QAAT,GAAoB,SAAS,MAAT,IAAmB,SAAS,IAAT,IAAiB,EAAjB,CAAvC,CARK;AASlB,WAAK,2BAAL,GATkB;AAUlB,WAAK,EAAL,CAAQ,IAAR,EAVkB;;;;;;mBAapB;oBAAO;AACL,UAAI,KAAK,YAAL,EAAmB;AACrB,cAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN,CADqB;OAAvB;;AAIA,WAAK,YAAL,GAAoB,IAApB,CALK;;;;;;mBAQP;sBAAS;;;AACP,WAAK,GAAL,CAAS,MAAT,CAAgB,SAAhB,CAA0B,IAA1B,EAAgC,YAAM;AACpC,eAAK,EAAL,CAAQ,OAAK,QAAL,CAAc,IAAd,CAAR,CADoC;OAAN,CAAhC,CADO;;;;;;mBAMT;uBAAU,WAAW;AACnB,UAAI,CAAC,KAAK,QAAL,CAAc,KAAd,EAAqB;AACxB,eAAO,KAAP,CADwB;OAA1B;;AAIA,UAAM,UAAU,KAAK,QAAL,CAAc,KAAd,CAAoB,OAApB,CALG;AAMnB,UAAM,iBAAiB,KAAK,QAAL,CAAc,MAAd,CANJ;;AAQnB,UAAM,uCACD,gBACA,UAFC,CARa;;AAanB,WAAK,IAAM,CAAN,2CAAW,OAAhB,EAAwB;AACtB,YAAI,OAAO,CAAP,MAAc,IAAd,IAAsB,OAAO,CAAP,MAAc,SAAd,EAAyB;AACjD,iBAAO,OAAO,CAAP,CAAP,CADiD;SAAnD;OADF;;AAMA,UAAM,cAAc,KAAK,QAAL,CAAc,WAAd,CAnBD;;AAqBnB,WAAK,EAAL,CAAQ,OAAR,EAAiB,MAAjB,EAAyB,WAAzB,EArBmB;AAsBnB,aAAO,IAAP,CAtBmB;;;;;;mBAyBrB;4BAAe,WAAW;AACxB,UAAI,CAAC,KAAK,QAAL,CAAc,KAAd,EAAqB;AACxB,eAAO,KAAP,CADwB;OAA1B;;AAIA,UAAM,4CACD,KAAK,QAAL,CAAc,WAAd,EACA,UAFC,CALkB;;AAUxB,WAAK,IAAM,CAAN,2CAAW,YAAhB,EAA6B;AAC3B,YAAI,YAAY,CAAZ,MAAmB,IAAnB,IAA2B,YAAY,CAAZ,MAAmB,SAAnB,EAA8B;AAC3D,iBAAO,YAAY,CAAZ,CAAP,CAD2D;SAA7D;OADF;;AAMA,UAAM,UAAU,KAAK,QAAL,CAAc,KAAd,CAAoB,OAApB,CAhBQ;AAiBxB,UAAM,SAAS,KAAK,QAAL,CAAc,MAAd,CAjBS;AAkBxB,WAAK,EAAL,CAAQ,OAAR,EAAiB,MAAjB,EAAyB,WAAzB,EAlBwB;AAmBxB,aAAO,IAAP,CAnBwB;;;;;;mBAsB1B;8BAAiB,IAAI;AACnB,aAAO,KAAK,GAAL,CAAS,YAAT,CAAsB,SAAtB,CAAgC,IAAhC,EAAsC,EAAtC,CAAP,CADmB;;;;;;mBAIrB;+BAAkB;AAChB,WAAK,YAAL,CAAkB,MAAlB,GADgB;;;;;;mBAIlB;sBAAS,KAAK;;;;;;;;;;AAUZ,UAAM,QAAQ,KAAK,OAAL,CAAa,GAAb,CAAiB,GAAjB,CAAR,CAVM;AAWZ,UAAI,KAAK,GAAL,CAAS,QAAT,CAAkB,GAAlB,EAAJ,EAA6B;AAC3B,eAAO,KAAK,QAAL,CAAc,MAAd,CAAqB,GAArB,CAAP,CAD2B;OAA7B;;AAIA,aAAO,KAAP,CAfY;;;;;;mBAkBd;2BAAc,KAAK;;AAEjB,UAAM,QAAQ,KAAK,YAAL,CAAkB,GAAlB,CAAsB,GAAtB,CAAR,CAFW;AAGjB,UAAI,KAAK,GAAL,CAAS,QAAT,CAAkB,GAAlB,EAAJ,EAA6B;AAC3B,eAAO,KAAK,QAAL,CAAc,WAAd,CAA0B,GAA1B,CAAP,CAD2B;OAA7B;;AAIA,aAAO,KAAP,CAPiB;;;;;;mBAUnB;4BAAe;AACb,WAAK,eAAL,GADa;AAEb,aAAO,KAAK,QAAL,CAAc,KAAd,CAAoB,IAApB,CAFM;;;;;;mBAKf;mBAAM,SAAS,SAAS,OAAO;AAC7B,UAAM,eAAe,wBAAM,KAAN,YAAY,OAAZ,EAAqB,OAArB,EAA8B,KAA9B,CAAf,CADuB;AAE7B,UAAM,OAAO,EAAP,CAFuB;AAG7B,UAAM,SAAS,+BAAa,OAAb,EAAsB,IAAtB,CAAT,CAHuB;AAI7B,WAAK,UAAL,CAAgB,IAAhB,CAAqB,EAAC,cAAD,EAAS,UAAT,EAAe,gBAAf,EAAwB,OAAO,YAAP,EAA7C,EAJ6B;;AAM7B,aAAO,YAAP,CAN6B;;;;;;mBAS/B;gBAAG,SAAS,QAAQ,aAAa;;;AAC/B,UAAM,OAAO,KAAK,IAAL,CAAU,OAAV,EAAmB,MAAnB,EAA2B,WAA3B,CAAP,CADyB;;AAG/B,UAAI,CAAC,IAAD,EAAO;AACT,eAAO,KAAP,CAAa,sCAAb,EADS;AAET,eAFS;OAAX;;AAKA,UAAM,UAAU,KAAK,aAAL,CAAmB,IAAnB,CAAV;;;AARyB,UAWzB,gBAAgB,KAAK,GAAL,CAAS,MAAT,CAAgB,GAAhB,EAAhB,CAXyB;AAY/B,UAAI,KAAK,QAAL,CAAc,IAAd,KAAuB,IAAvB,IAA+B,CAAC,aAAD,EAAgB;AACjD,eADiD;OAAnD;;AAIA,UAAM,iBAAiB,KAAK,aAAL,CAAmB,gBAAG,KAAH,CAAS,QAAQ,WAAR,CAA5B,CAAjB;;;AAhByB,UAmB3B,WAAW,QAAQ,QAAR,CAnBgB;AAoB/B,UAAI,KAAK,SAAL,EAAgB;AAClB,YAAM,kBAAkB,KAAK,SAAL,CACrB,IADqB,GAErB,OAFqB,CAEb,KAFa,EAEN,EAFM,EAGrB,OAHqB,CAGb,KAHa,EAGN,EAHM,CAAlB,CADY;AAKlB,mBAAW,QAAQ,QAAR,CAAiB,OAAjB,OAA6B,eAA7B,EAAgD,EAAhD,CAAX,CALkB;OAApB;;;uBAQS;AACP,cAAM,WAAW,OAAK,UAAL,CAAgB,EAAhB,CAAX;AACN,cAAM,UAAU,SAAS,MAAT,CAAgB,IAAhB,CAAqB,QAArB,CAAV;AACN,cAAI,OAAJ,EAAa;;AACX,kBAAM,SAAS,EAAT;AACN,uBAAS,IAAT,CAAc,OAAd,CAAsB,gBAAS,KAAT,EAAmB;oBAAjB,iBAAiB;;AACvC,oBAAM,QAAQ,QAAQ,QAAQ,CAAR,CAAhB,CADiC;AAEvC,uBAAO,IAAP,IAAe,OAAO,KAAP,KAAiB,WAAjB,GAA+B,mBAAmB,KAAnB,CAA/B,GAA2D,KAA3D,CAFwB;eAAnB,CAAtB;;AAKA,kBAAM,+CACD;AACH;AACA,6BAAa,cAAb;AACA,uBAAO,SAAS,KAAT;gBAJH;;AAON,qBAAK,SAAL,CAAe,cAAf;AACA;;;;;gBAfW;;;WAAb;;;;UA/B6B;;AA4B/B,WAAK,IAAI,KAAK,CAAL,EAAQ,KAAK,KAAK,UAAL,CAAgB,MAAhB,EAAwB,IAA9C,EAAoD;yBAA3C,IAA2C;;;OAApD;;AAsBA,UAAM,gBAAgB,KAAK,iBAAL,EAAhB,CAlDyB;AAmD/B,UAAM,gDACD;AACH,eAAO,aAAP;AACA,gBAAQ,EAAR;AACA,qBAAa,cAAb;QAJI,CAnDyB;AAyD/B,WAAK,SAAL,CAAe,eAAf,EAzD+B;;;;;;mBA4DjC;uBAAU,SAAS;AACjB,UAAM,8DACD,KAAK,cAAL,uCACA,QAAQ,KAAR,CAAc,cAAd,EAFC,CADW;AAKjB,UAAM,eAAe,KAAK,YAAL,CAAkB,aAAlB,EAAiC,OAAjC,CAAf,CALW;;AAOjB,UAAI,YAAJ,EAAkB;AAChB,eAAO,KAAK,EAAL,iDAAW,aAAX,CAAP,CADgB;OAAlB;;;AAPiB,UAYX,aAAa,KAAK,QAAL,CAZF;AAajB,WAAK,QAAL,GAAgB,OAAhB;;;AAbiB,UAgBb,cAAc,WAAW,KAAX,EAAkB;AAClC,YAAM,6DACD,KAAK,aAAL,uCACA,WAAW,KAAX,CAAiB,aAAjB,EAFC,CAD4B;AAKlC,YAAM,mBAAmB,KAAK,YAAL,CAAkB,YAAlB,EAAgC,UAAhC,CAAnB,CAL4B;;AAOlC,YAAI,gBAAJ,EAAsB;AACpB,iBAAO,KAAK,EAAL,iDAAW,iBAAX,CAAP,CADoB;SAAtB;OAPF;;;;AAhBiB,UA8Bb,CAAC,KAAK,GAAL,CAAS,UAAT,CAAoB,GAApB,EAAD,EAA4B;AAC9B,YAAM,kBAAkB,KAAK,GAAL,CAAS,YAAT,CAAsB,GAAtB,EAAlB,CADwB;YAEvB,OAA6B,QAA7B,KAFuB;YAEjB,SAAuB,QAAvB,OAFiB;YAET,cAAe,QAAf,YAFS;;AAG9B,YAAM,WAAW,EAAC,UAAD,EAAO,cAAP,EAAe,wBAAf,EAAX,CAHwB;AAI9B,YAAI,eAAJ,EAAqB;AACnB,kBAAQ,YAAR,CAAqB,QAArB,EAA+B,OAAO,KAAP,EAAc,IAA7C,EADmB;SAArB,MAEO;AACL,kBAAQ,SAAR,CAAkB,QAAlB,EAA4B,OAAO,KAAP,EAAc,IAA1C,EADK;SAFP;OAJF;;AAWA,WAAK,WAAL,GAzCiB;;;;;;mBA4CnB;2BAAc;;;AACZ,UAAM,iBAAiB,KAAK,QAAL,CADX;AAEZ,UAAM,QAAQ,eAAe,KAAf;;;;AAFF,aAMZ,CAAQ,WAAR,CAAoB,YAAM;AACxB,eAAK,GAAL,CAAS,QAAT,CAAkB,SAAlB,CAA4B,IAA5B,EAAkC,YAAM;AACtC,gBAAM,UAAN,CAAiB,cAAjB,EADsC;SAAN,CAAlC,CADwB;;AAKxB,gBAAQ,UAAR,CAAmB,YAAM;AACvB,iBAAK,YAAL,CAAkB,OAAlB,GADuB;AAEvB,iBAAK,mBAAL,CAAyB,OAAK,OAAL,EAAc,eAAe,MAAf,CAAvC,CAFuB;AAGvB,iBAAK,mBAAL,CAAyB,OAAK,YAAL,EAAmB,eAAe,WAAf,CAA5C,CAHuB;SAAN,CAAnB,CALwB;OAAN,CAApB,CANY;;;;;;mBAmBd;iCAAoB;AAClB,UAAM,kBAAkB,KAAK,QAAL,IAAiB;AACvC;4BAAS;AACP,gBAAM,UAAU,WAAW,OAAX,EAAV,CADC;AAEP,mBAAO,KAAP,CAAa,iCAAb,EAAgD,QAAQ,IAAR,CAAhD,CAFO;;;;WAD8B;OAAjB,CADN;;AAQlB,aAAO,IAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB,EAAqB,eAArB,CAAP,CARkB;;;;;;mBAWpB;0BAAa,UAAU,SAAS;AAC9B,UAAI,qBAAJ,CAD8B;AAE9B,UAAM;AAAa,iBAAb,UAAa,CAAC,GAAD,EAAM,MAAN,EAAc,WAAd,EAA8B;AAC/C,cAAI,iBAAiB,IAAjB,CAAsB,GAAtB,CAAJ,EAAgC;AAC9B,gBAAM,yLAAN,CAD8B;AAM9B,kBAAM,IAAI,KAAJ,CAAU,OAAV,CAAN,CAN8B;WAAhC;AAQA,yBAAe,CAAC,GAAD,EAAM,MAAN,EAAc,WAAd,CAAf,CAT+C;SAA9B;;eAAb;SAAN,CAF8B;;AAc9B,eAAS,WAAT,CACE,QADF,EAEE,OAFF,EAGE,UAHF,EAIE,YAAM,EAAN,CAJF,CAd8B;;AAqB9B,aAAO,YAAP,CArB8B;;;;;;mBAwBhC;2BAAc,KAAK;AACjB,UAAM,SAAS,EAAT,CADW;AAEjB,aAAO,IAAP,CAAY,GAAZ,EAAiB,OAAjB,CAAyB,eAAO;AAC9B,YAAM,QAAQ,IAAI,GAAJ,CAAR,CADwB;AAE9B,eAAO,GAAP,IAAc,OAAO,KAAP,KAAiB,WAAjB,GAA+B,mBAAmB,KAAnB,CAA/B,GAA2D,KAA3D,CAFgB;OAAP,CAAzB,CAFiB;;AAOjB,aAAO,MAAP,CAPiB;;;;;;mBAUnB;iCAAoB,MAAM,WAAW;AACnC,UAAM,cAAc,EAAE,IAAF,CAAO,SAAP,CAAd,CAD6B;AAEnC,UAAM,UAAU,EAAE,IAAF,CAAO,KAAK,OAAL,CAAjB;;;AAF6B,iBAKnC,CAAY,OAAZ,CAAoB,UAAC,GAAD,EAAS;AAC3B,aAAK,GAAL,CAAS,GAAT,EAAc,UAAU,GAAV,CAAd,EAD2B;OAAT,CAApB;;;AALmC,UAU7B,cAAc,EAAE,UAAF,CAAa,OAAb,EAAsB,WAAtB,CAAd,CAV6B;AAWnC,kBAAY,OAAZ,CAAoB,UAAC,GAAD,EAAS;AAC3B,aAAK,GAAL,CAAS,GAAT,EAAc,SAAd,EAD2B;OAAT,CAApB,CAXmC;;;;;;mBAgBrC;gCAAmB;;;AACjB,WAAK,QAAL,GAAgB;AACd;AAAO,yBAAC,QAAD,EAAW,MAAX,EAAsB;AAC3B,uBAAW,SAAS,YAAT,CAAsB,QAAtB,EAAgC,MAAhC,CAAX,CAD2B;AAE3B,gBAAI,SAAS,MAAT,EAAiB;AACnB,qBAAK,cAAL,GAAsB,OAAK,cAAL,CAAoB,MAApB,CAA2B,QAA3B,CAAtB,CADmB;aAArB;WAFK;;;WAAP;;AAOA;AAAM,wBAAC,QAAD,EAAW,MAAX,EAAsB;AAC1B,uBAAW,SAAS,YAAT,CAAsB,QAAtB,EAAgC,MAAhC,CAAX,CAD0B;AAE1B,gBAAI,SAAS,MAAT,EAAiB;AACnB,qBAAK,aAAL,GAAqB,OAAK,aAAL,CAAmB,MAAnB,CAA0B,QAA1B,CAArB,CADmB;aAArB;WAFI;;;WAAN;OARF,CADiB;;;;;;;;;mBAmBnB;uCAA0B;AACxB,aAAO,KAAK,QAAL,CADiB;;;;;;mBAI1B;wCAA2B;;;AAGzB,UAAM,OAAO,IAAP,CAHmB;AAIzB,UAAM,aACJ,OAAO,QAAP,KAAoB,WAApB,IAAmC,SAAS,YAAT,GACnC,YADA,GACe,OADf,CALuB;AAOzB,eAAS,gBAAT,CAA0B,UAA1B,EAAsC,OAAtC,EAA+C,KAA/C,EAPyB;;AASzB,eAAS,OAAT,CAAiB,CAAjB,EAAoB;AAClB,YAAI,MAAM,CAAN,MAAa,CAAb,EAAgB;AAClB,iBADkB;SAApB;;AAIA,YAAI,EAAE,OAAF,IAAa,EAAE,OAAF,IAAa,EAAE,QAAF,EAAY;AACxC,iBADwC;SAA1C;;AAIA,YAAI,EAAE,gBAAF,EAAoB;AACtB,iBADsB;SAAxB;;;;AATkB,YAed,KAAK,EAAE,IAAF,GAAS,EAAE,IAAF,CAAO,CAAP,CAAT,GAAqB,EAAE,MAAF,CAfZ;AAgBlB,eAAO,MAAM,GAAG,QAAH,KAAgB,GAAhB,EAAsB;AACjC,eAAK,GAAG,UAAH,CAD4B;SAAnC;;AAIA,YAAI,CAAC,EAAD,IAAO,GAAG,QAAH,KAAgB,GAAhB,EAAqB;AAC9B,iBAD8B;SAAhC;;;;;AApBkB,YA2Bd,GAAG,YAAH,CAAgB,UAAhB,KAA+B,GAAG,YAAH,CAAgB,KAAhB,MAA2B,UAA3B,EAAuC;AACxE,iBADwE;SAA1E;;;AA3BkB,YAgCZ,OAAO,GAAG,YAAH,CAAgB,MAAhB,CAAP,CAhCY;AAiClB,YAAI,GAAG,QAAH,KAAgB,SAAS,QAAT,KAAsB,GAAG,IAAH,IAAW,SAAS,GAAT,CAAjD,EAAgE;AAClE,iBADkE;SAApE;;;AAjCkB,YAsCd,QAAQ,KAAK,OAAL,CAAa,SAAb,IAA0B,CAAC,CAAD,EAAI;AACxC,iBADwC;SAA1C;;;AAtCkB,YA2Cd,GAAG,MAAH,EAAW;AACb,iBADa;SAAf;;;AA3CkB,YAgDd,CAAC,WAAW,GAAG,IAAH,CAAZ,EAAsB;AACxB,iBADwB;SAA1B;;;AAhDkB,YAqDd,OAAO,GAAG,QAAH,GAAc,GAAG,MAAH,IAAa,GAAG,IAAH,IAAW,EAAX,CAA3B;;;AArDO,YAwDd,OAAO,OAAP,KAAmB,WAAnB,IAAkC,KAAK,KAAL,CAAW,gBAAX,CAAlC,EAAgE;AAClE,iBAAO,KAAK,OAAL,CAAa,gBAAb,EAA+B,GAA/B,CAAP,CADkE;SAApE;;AAIA,UAAE,cAAF,GA5DkB;AA6DlB,aAAK,EAAL,CAAQ,IAAR,EA7DkB;OAApB;;AAgEA,eAAS,KAAT,CAAe,CAAf,EAAkB;AAChB,YAAI,KAAK,OAAO,KAAP,CADO;AAEhB,eAAO,EAAE,KAAF,KAAY,IAAZ,GAAmB,EAAE,MAAF,GAAW,EAAE,KAAF,CAFrB;OAAlB;;AAKA,eAAS,UAAT,CAAoB,IAApB,EAA0B;AACxB,YAAI,SAAY,SAAS,QAAT,UAAsB,SAAS,QAAT,CADd;AAExB,YAAI,SAAS,IAAT,EAAe;AACjB,0BAAc,SAAS,IAAT,CADG;SAAnB;;AAIA,eAAO,QAAQ,KAAK,OAAL,CAAa,MAAb,MAAyB,CAAzB,CANS;OAA1B;;;;;;mBAUF;2CAA8B;AAC5B,UAAM,OAAO,IAAP,CADsB;AAE5B,aAAO,gBAAP,CAAwB,UAAxB,EAAoC,UAApC,EAAgD,KAAhD,EAF4B;;AAI5B,eAAS,UAAT,GAAsB;;;;;AAKpB,YAAM,OAAO,SAAS,QAAT,GAAoB,SAAS,MAAT,IAAmB,SAAS,IAAT,IAAiB,EAAjB,CAAvC,CALO;AAMpB,aAAK,GAAL,CAAS,UAAT,CAAoB,SAApB,CAA8B,IAA9B,EAAoC,YAAW;AAC7C,eAAK,EAAL,CAAQ,IAAR,EAD6C;SAAX,CAApC,CANoB;OAAtB;;;;;;mBAYF;2BAAc,MAAM;AAClB,UAAM,YAAY,2BAAS,EAAC,KAAK,IAAL,EAAV,CAAZ,CADY;;AAGlB,UAAM,UAAU;AACd,kBADc;AAEd,kBAAU,UAAU,QAAV;AACV,cAAM,UAAU,IAAV,GAAiB,UAAU,IAAV,CAAe,MAAf,CAAsB,CAAtB,CAAjB,GAA4C,IAA5C;AACN,qBAAa,UAAU,MAAV,GAAmB,UAAU,MAAV,CAAiB,MAAjB,CAAwB,CAAxB,CAAnB,GAAgD,IAAhD;OAJT,CAHY;;AAUlB,aAAO,OAAP,CAVkB;;;;;;;EAzdC,aAAvB","file":"/packages/kadira:flow-router-ssr/client/router.js.map","sourcesContent":["/* eslint new-cap: 0, no-loop-func: 0, prefer-arrow-callback: 0 */\nimport Qs from 'qs';\nimport PathToRegexp from 'path-to-regexp';\nimport ParseUrl from 'parseurl';\nconst logger = console;\n\nRouter = class extends SharedRouter {\n  constructor() {\n    super();\n\n    // holds the current context\n    this._current = {};\n\n    // tracks the current path change\n    this._onEveryPath = new Tracker.Dependency();\n    this._params = new ReactiveDict();\n    this._queryParams = new ReactiveDict();\n\n    // if _askedToWait is true. We don't automatically start the router\n    // in Meteor.startup callback. (see client/_init.js)\n    // Instead user need to call `.initialize()\n    this._askedToWait = false;\n    this._initialized = false;\n\n    this._triggersEnter = [];\n    this._triggersExit = [];\n\n    // Meteor exposes to the client the path prefix that was defined using the\n    // ROOT_URL environement variable on the server using the global runtime\n    // configuration. See #315.\n    this._basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n\n    this.env.replaceState = new Meteor.EnvironmentVariable();\n    this.env.reload = new Meteor.EnvironmentVariable();\n    this.env.inAction = new Meteor.EnvironmentVariable();\n    this.env.inPopstate = new Meteor.EnvironmentVariable();\n\n    // this holds route pathDefs\n    this._routeDefs = [];\n\n    this._initTriggersAPI();\n    this._initClickAnchorHandlers();\n  }\n\n  initialize(options) {\n    options = options || {};\n\n    if (this._initialized) {\n      throw new Error('FlowRouter is already initialized');\n    }\n\n    this._initialized = true;\n    const path = location.pathname + location.search + (location.hash || '');\n    this._initiateHandlingBackButton();\n    this.go(path);\n  }\n\n  wait() {\n    if (this._initialized) {\n      throw new Error(\"can't wait after FlowRouter has been initialized\");\n    }\n\n    this._askedToWait = true;\n  }\n\n  reload() {\n    this.env.reload.withValue(true, () => {\n      this.go(this._current.path);\n    });\n  }\n\n  setParams(newParams) {\n    if (!this._current.route) {\n      return false;\n    }\n\n    const pathDef = this._current.route.pathDef;\n    const existingParams = this._current.params;\n\n    const params = {\n      ...existingParams,\n      ...newParams\n    };\n\n    for (const k in params) {\n      if (params[k] === null || params[k] === undefined) {\n        delete params[k];\n      }\n    }\n\n    const queryParams = this._current.queryParams;\n\n    this.go(pathDef, params, queryParams);\n    return true;\n  }\n\n  setQueryParams(newParams) {\n    if (!this._current.route) {\n      return false;\n    }\n\n    const queryParams = {\n      ...this._current.queryParams,\n      ...newParams\n    };\n\n    for (const k in queryParams) {\n      if (queryParams[k] === null || queryParams[k] === undefined) {\n        delete queryParams[k];\n      }\n    }\n\n    const pathDef = this._current.route.pathDef;\n    const params = this._current.params;\n    this.go(pathDef, params, queryParams);\n    return true;\n  }\n\n  withReplaceState(fn) {\n    return this.env.replaceState.withValue(true, fn);\n  }\n\n  watchPathChange() {\n    this._onEveryPath.depend();\n  }\n\n  getParam(key) {\n    // We update this._params reactive store only after we Tracker.afterFlush\n    // event to make sure, older routes does not get the updated value even\n    // before the new UI is rendered.\n    //\n    // But, then it cause issues for the new route(in the action)\n    // where if picks up older data.\n    //\n    // That's why we directly get values from the context when called\n    // inside an action.\n    const value = this._params.get(key);\n    if (this.env.inAction.get()) {\n      return this._current.params[key];\n    }\n\n    return value;\n  }\n\n  getQueryParam(key) {\n    // See above .getParam() for more information.\n    const value = this._queryParams.get(key);\n    if (this.env.inAction.get()) {\n      return this._current.queryParams[key];\n    }\n\n    return value;\n  }\n\n  getRouteName() {\n    this.watchPathChange();\n    return this._current.route.name;\n  }\n\n  route(pathDef, options, group) {\n    const currentRoute = super.route(pathDef, options, group);\n    const keys = [];\n    const regexp = PathToRegexp(pathDef, keys);\n    this._routeDefs.push({regexp, keys, pathDef, route: currentRoute});\n\n    return currentRoute;\n  }\n\n  go(pathDef, fields, queryParams) {\n    const path = this.path(pathDef, fields, queryParams);\n\n    if (!path) {\n      logger.error('Path is required for FlowRouter.go()');\n      return;\n    }\n\n    const context = this._buildContext(path);\n\n    // Implement idempotant routing\n    const insideAReload = this.env.reload.get();\n    if (this._current.path === path && !insideAReload) {\n      return;\n    }\n\n    const allQueryParams = this._decodeValues(Qs.parse(context.queryString));\n\n    // Remove basePath from the path\n    let pathname = context.pathname;\n    if (this._basePath) {\n      const cleanedBasePath = this._basePath\n        .trim()\n        .replace(/^\\//, '')\n        .replace(/$\\//, '');\n      pathname = context.pathname.replace(`/${cleanedBasePath}`, '');\n    }\n\n    for (let lc = 0; lc < this._routeDefs.length; lc++) {\n      const routeDef = this._routeDefs[lc];\n      const matched = routeDef.regexp.exec(pathname);\n      if (matched) {\n        const params = {};\n        routeDef.keys.forEach(({name}, index) => {\n          const match = matched[index + 1];\n          params[name] = typeof match !== 'undefined' ? decodeURIComponent(match) : match;\n        });\n\n        const matchedContext = {\n          ...context,\n          params,\n          queryParams: allQueryParams,\n          route: routeDef.route\n        };\n\n        this._navigate(matchedContext);\n        return;\n      }\n    }\n\n    const notFoundRoute = this._getNotFoundRoute();\n    const notFoundContext = {\n      ...context,\n      route: notFoundRoute,\n      params: {},\n      queryParams: allQueryParams\n    };\n    this._navigate(notFoundContext);\n  }\n\n  _navigate(context) {\n    const triggersEnter = [\n      ...this._triggersEnter,\n      ...context.route._triggersEnter\n    ];\n    const redirectArgs = this._runTriggers(triggersEnter, context);\n\n    if (redirectArgs) {\n      return this.go(...redirectArgs);\n    }\n\n    // Set the current context\n    const oldContext = this._current;\n    this._current = context;\n\n    // Run exit handlers\n    if (oldContext && oldContext.route) {\n      const triggersExit = [\n        ...this._triggersExit,\n        ...oldContext.route._triggersExit\n      ];\n      const exitRedirectArgs = this._runTriggers(triggersExit, oldContext);\n\n      if (exitRedirectArgs) {\n        return this.go(...exitRedirectArgs);\n      }\n    }\n\n    // If we are inside a popstate event,\n    // we should not change the history\n    if (!this.env.inPopstate.get()) {\n      const useReplaceState = this.env.replaceState.get();\n      const {path, params, queryParams} = context;\n      const urlState = {path, params, queryParams};\n      if (useReplaceState) {\n        history.replaceState(urlState, window.title, path);\n      } else {\n        history.pushState(urlState, window.title, path);\n      }\n    }\n\n    this._applyRoute();\n  }\n\n  _applyRoute() {\n    const currentContext = this._current;\n    const route = currentContext.route;\n\n    // otherwise, computations inside action will trigger to re-run\n    // this computation. which we do not need.\n    Tracker.nonreactive(() => {\n      this.env.inAction.withValue(true, () => {\n        route.callAction(currentContext);\n      });\n\n      Tracker.afterFlush(() => {\n        this._onEveryPath.changed();\n        this._updateReactiveDict(this._params, currentContext.params);\n        this._updateReactiveDict(this._queryParams, currentContext.queryParams);\n      });\n    });\n  }\n\n  _getNotFoundRoute() {\n    const notFoundOptions = this.notFound || {\n      action() {\n        const current = FlowRouter.current();\n        logger.error('There is no route for the path:', current.path);\n      }\n    };\n\n    return new Route(this, '*', notFoundOptions);\n  }\n\n  _runTriggers(triggers, context) {\n    let redirectArgs;\n    const redirectFn = (url, params, queryParams) => {\n      if (/^http(s)?:\\/\\//.test(url)) {\n        const message = `\n          Redirects to URLs outside of the app are not supported\n          in this version of Flow Router.\n          Use 'window.location = yourUrl' instead.\n        `;\n        throw new Error(message);\n      }\n      redirectArgs = [url, params, queryParams];\n    };\n\n    Triggers.runTriggers(\n      triggers,\n      context,\n      redirectFn,\n      () => {}\n    );\n\n    return redirectArgs;\n  }\n\n  _decodeValues(obj) {\n    const newObj = {};\n    Object.keys(obj).forEach(key => {\n      const value = obj[key];\n      newObj[key] = typeof value !== 'undefined' ? decodeURIComponent(value) : value;\n    });\n\n    return newObj;\n  }\n\n  _updateReactiveDict(dict, newValues) {\n    const currentKeys = _.keys(newValues);\n    const oldKeys = _.keys(dict.keyDeps);\n\n    // set new values\n    currentKeys.forEach((key) => {\n      dict.set(key, newValues[key]);\n    });\n\n    // remove keys which does not exisits here\n    const removedKeys = _.difference(oldKeys, currentKeys);\n    removedKeys.forEach((key) => {\n      dict.set(key, undefined);\n    });\n  }\n\n  _initTriggersAPI() {\n    this.triggers = {\n      enter: (triggers, filter) => {\n        triggers = Triggers.applyFilters(triggers, filter);\n        if (triggers.length) {\n          this._triggersEnter = this._triggersEnter.concat(triggers);\n        }\n      },\n\n      exit: (triggers, filter) => {\n        triggers = Triggers.applyFilters(triggers, filter);\n        if (triggers.length) {\n          this._triggersExit = this._triggersExit.concat(triggers);\n        }\n      }\n    };\n  }\n\n  // This is required for implementing a router class.\n  _getCurrentRouteContext() {\n    return this._current;\n  }\n\n  _initClickAnchorHandlers() {\n    // This logic is taken from page.js\n    // See: https://github.com/visionmedia/page.js\n    const self = this;\n    const clickEvent =\n      typeof document !== 'undefined' && document.ontouchstart ?\n      'touchstart' : 'click';\n    document.addEventListener(clickEvent, onclick, false);\n\n    function onclick(e) {\n      if (which(e) !== 1) {\n        return;\n      }\n\n      if (e.metaKey || e.ctrlKey || e.shiftKey) {\n        return;\n      }\n\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      // ensure link\n      // use shadow dom when available\n      let el = e.path ? e.path[0] : e.target;\n      while (el && el.nodeName !== 'A' ) {\n        el = el.parentNode;\n      }\n\n      if (!el || el.nodeName !== 'A') {\n        return;\n      }\n\n      // Ignore if tag has\n      // 1. \"download\" attribute\n      // 2. rel=\"external\" attribute\n      if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') {\n        return;\n      }\n\n      // ensure non-hash for the same path\n      const link = el.getAttribute('href');\n      if (el.pathname === location.pathname && (el.hash || link === '#')) {\n        return;\n      }\n\n      // Check for mailto: in the href\n      if (link && link.indexOf('mailto:') > -1) {\n        return;\n      }\n\n      // check target\n      if (el.target) {\n        return;\n      }\n\n      // x-origin\n      if (!sameOrigin(el.href)) {\n        return;\n      }\n\n      // rebuild path\n      let path = el.pathname + el.search + (el.hash || '');\n\n      // strip leading \"/[drive letter]:\" on NW.js on Windows\n      if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n        path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n      }\n\n      e.preventDefault();\n      self.go(path);\n    }\n\n    function which(e) {\n      e = e || window.event;\n      return e.which === null ? e.button : e.which;\n    }\n\n    function sameOrigin(href) {\n      let origin = `${location.protocol}//${location.hostname}`;\n      if (location.port) {\n        origin += `:${location.port}`;\n      }\n\n      return href && href.indexOf(origin) === 0;\n    }\n  }\n\n  _initiateHandlingBackButton() {\n    const self = this;\n    window.addEventListener('popstate', onpopstate, false);\n\n    function onpopstate() {\n      // In some browsers they fire popstate event right after page has loaded.\n      // That's not the correct way for the popstate.\n      // Normally, we need to handle it.\n      // But, we don't want to do it since self.go() is already idempotent.\n      const path = location.pathname + location.search + (location.hash || '');\n      self.env.inPopstate.withValue(true, function() {\n        self.go(path);\n      });\n    }\n  }\n\n  _buildContext(path) {\n    const parsedUrl = ParseUrl({url: path});\n\n    const context = {\n      path,\n      pathname: parsedUrl.pathname,\n      hash: parsedUrl.hash ? parsedUrl.hash.substr(1) : null,\n      queryString: parsedUrl.search ? parsedUrl.search.substr(1) : null\n    };\n\n    return context;\n  }\n};\n"]},"hash":"ee70b51f49ef912e8e607d7c61373269b083fdc3"}
