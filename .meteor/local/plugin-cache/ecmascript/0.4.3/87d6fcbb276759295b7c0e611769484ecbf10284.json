{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/kadira:flow-router-ssr/client/triggers.js","filenameRelative":"/packages/kadira:flow-router-ssr/client/triggers.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/kadira:flow-router-ssr/client/triggers.js.map","sourceFileName":"/packages/kadira:flow-router-ssr/client/triggers.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"triggers"},"ignored":false,"code":"// a set of utility functions for triggers\n\nTriggers = {};\n\n// Apply filters for a set of triggers\n// @triggers - a set of triggers\n// @filter - filter with array fileds with `only` and `except`\n//           support only either `only` or `except`, but not both\nTriggers.applyFilters = function (triggers, filter) {\n  if (!(triggers instanceof Array)) {\n    triggers = [triggers];\n  }\n\n  if (!filter) {\n    return triggers;\n  }\n\n  if (filter.only && filter.except) {\n    throw new Error(\"Triggers don't support only and except filters at once\");\n  }\n\n  if (filter.only && !(filter.only instanceof Array)) {\n    throw new Error('only filters needs to be an array');\n  }\n\n  if (filter.except && !(filter.except instanceof Array)) {\n    throw new Error('except filters needs to be an array');\n  }\n\n  if (filter.only) {\n    return Triggers.createRouteBoundTriggers(triggers, filter.only);\n  }\n\n  if (filter.except) {\n    return Triggers.createRouteBoundTriggers(triggers, filter.except, true);\n  }\n\n  throw new Error('Provided a filter but not supported');\n};\n\n//  create triggers by bounding them to a set of route names\n//  @triggers - a set of triggers\n//  @names - list of route names to be bound (trigger runs only for these names)\n//  @negate - negate the result (triggers won't run for above names)\nTriggers.createRouteBoundTriggers = function (triggers, names, negate) {\n  var namesMap = {};\n\n  names.forEach(function (name) {\n    namesMap[name] = true;\n  });\n\n  var filteredTriggers = triggers.map(function (originalTrigger) {\n    var modifiedTrigger = function modifiedTrigger(context, next) {\n      var routeName = context.route.name;\n      var matched = namesMap[routeName] ? 1 : -1;\n      matched = negate ? matched * -1 : matched;\n\n      if (matched === 1) {\n        originalTrigger(context, next);\n      }\n    };\n    return modifiedTrigger;\n  });\n\n  return filteredTriggers;\n};\n\n//  run triggers and abort if redirected or callback stopped\n//  @triggers - a set of triggers\n//  @context - context we need to pass (it must have the route)\n//  @redirectFn - function which used to redirect\n//  @after - called after if only all the triggers runs\nTriggers.runTriggers = function (triggers, context, redirectFn, after) {\n  var abort = false;\n  var inCurrentLoop = true;\n  var alreadyRedirected = false;\n\n  for (var lc = 0; lc < triggers.length; lc++) {\n    var trigger = triggers[lc];\n    trigger(context, doRedirect, doStop);\n\n    if (abort) {\n      return;\n    }\n  }\n\n  // mark that, we've exceeds the currentEventloop for\n  // this set of triggers.\n  inCurrentLoop = false;\n  after();\n\n  function doRedirect(url, params, queryParams) {\n    if (alreadyRedirected) {\n      throw new Error('already redirected');\n    }\n\n    if (!inCurrentLoop) {\n      throw new Error('redirect needs to be done in sync');\n    }\n\n    if (!url) {\n      throw new Error('trigger redirect requires an URL');\n    }\n\n    abort = true;\n    alreadyRedirected = true;\n    redirectFn(url, params, queryParams);\n  }\n\n  function doStop() {\n    abort = true;\n  }\n};","ast":null,"map":{"version":3,"sources":["/packages/kadira:flow-router-ssr/client/triggers.js"],"names":[],"mappings":"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","file":"/packages/kadira:flow-router-ssr/client/triggers.js.map","sourcesContent":["// a set of utility functions for triggers\n\nTriggers = {};\n\n// Apply filters for a set of triggers\n// @triggers - a set of triggers\n// @filter - filter with array fileds with `only` and `except`\n//           support only either `only` or `except`, but not both\nTriggers.applyFilters = (triggers, filter) => {\n  if (!(triggers instanceof Array)) {\n    triggers = [triggers];\n  }\n\n  if (!filter) {\n    return triggers;\n  }\n\n  if (filter.only && filter.except) {\n    throw new Error(\"Triggers don't support only and except filters at once\");\n  }\n\n  if (filter.only && !(filter.only instanceof Array)) {\n    throw new Error('only filters needs to be an array');\n  }\n\n  if (filter.except && !(filter.except instanceof Array)) {\n    throw new Error('except filters needs to be an array');\n  }\n\n  if (filter.only) {\n    return Triggers.createRouteBoundTriggers(triggers, filter.only);\n  }\n\n  if (filter.except) {\n    return Triggers.createRouteBoundTriggers(triggers, filter.except, true);\n  }\n\n  throw new Error('Provided a filter but not supported');\n};\n\n//  create triggers by bounding them to a set of route names\n//  @triggers - a set of triggers\n//  @names - list of route names to be bound (trigger runs only for these names)\n//  @negate - negate the result (triggers won't run for above names)\nTriggers.createRouteBoundTriggers = (triggers, names, negate) => {\n  const namesMap = {};\n\n  names.forEach((name) => {\n    namesMap[name] = true;\n  });\n\n  const filteredTriggers = triggers.map((originalTrigger) => {\n    const modifiedTrigger = (context, next) => {\n      const routeName = context.route.name;\n      let matched = namesMap[routeName] ? 1 : -1;\n      matched = negate ? matched * -1 : matched;\n\n      if (matched === 1) {\n        originalTrigger(context, next);\n      }\n    };\n    return modifiedTrigger;\n  });\n\n  return filteredTriggers;\n};\n\n//  run triggers and abort if redirected or callback stopped\n//  @triggers - a set of triggers\n//  @context - context we need to pass (it must have the route)\n//  @redirectFn - function which used to redirect\n//  @after - called after if only all the triggers runs\nTriggers.runTriggers = (triggers, context, redirectFn, after) => {\n  let abort = false;\n  let inCurrentLoop = true;\n  let alreadyRedirected = false;\n\n  for (let lc = 0; lc < triggers.length; lc++) {\n    const trigger = triggers[lc];\n    trigger(context, doRedirect, doStop);\n\n    if (abort) {\n      return;\n    }\n  }\n\n  // mark that, we've exceeds the currentEventloop for\n  // this set of triggers.\n  inCurrentLoop = false;\n  after();\n\n  function doRedirect(url, params, queryParams) {\n    if (alreadyRedirected) {\n      throw new Error('already redirected');\n    }\n\n    if (!inCurrentLoop) {\n      throw new Error('redirect needs to be done in sync');\n    }\n\n    if (!url) {\n      throw new Error('trigger redirect requires an URL');\n    }\n\n    abort = true;\n    alreadyRedirected = true;\n    redirectFn(url, params, queryParams);\n  }\n\n  function doStop() {\n    abort = true;\n  }\n};\n"]},"hash":"87d6fcbb276759295b7c0e611769484ecbf10284"}
