{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/kadira:flow-router-ssr/server/route.js","filenameRelative":"/packages/kadira:flow-router-ssr/server/route.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/kadira:flow-router-ssr/server/route.js.map","sourceFileName":"/packages/kadira:flow-router-ssr/server/route.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"route"},"ignored":false,"code":"var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar Url = require('url');\nvar Cheerio = require('cheerio');\nvar logger = console;\n\nRoute = function (_SharedRoute) {\n  (0, _inherits3['default'])(Route, _SharedRoute);\n\n  function Route(router, pathDef, options, group) {\n    (0, _classCallCheck3['default'])(this, Route);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, _SharedRoute.call(this, router, pathDef, options, group));\n\n    _this._cache = {};\n    return _this;\n  }\n\n  Route.prototype._init = function () {\n    function _init() {\n      var cookieParser = require('cookie-parser');\n      Picker.middleware(cookieParser());\n      // process null subscriptions with FR support\n      Picker.middleware(FastRender.handleOnAllRoutes);\n\n      var route = FlowRouter.basePath + this.pathDef;\n      Picker.route(route, this._handleRoute.bind(this));\n    }\n\n    return _init;\n  }();\n\n  Route.prototype._handleRoute = function () {\n    function _handleRoute(params, req, res, next) {\n      if (!this._isHtmlPage(req.url)) {\n        return next();\n      }\n\n      // This userId will be useful in the at the later on when\n      // it's time to cache the page.\n      // Normally, we can't access `Meteor.userId()` outside of a method\n      // But here, we could do it because we call `FastRender.handleOnAllRoutes`.\n      // It creates a FastRender context and assign it for the current fiber.\n      req.__userId = Meteor.userId();\n      var cachedPage = this._getCachedPage(req.url, req.__userId);\n      if (cachedPage) {\n        return this._processFromCache(cachedPage, res, next);\n      }\n\n      // Here we need to processFromSsr,\n      // but also we need to process with FastRender as well.\n      // That's why we bind processFromSsr and pass args as below.\n      // It does not get any arguments from FastRender.\n      // FastRender just trigger the following handler and do it's job\n      var processFromSsr = this._processFromSsr.bind(this, params, req, res);\n      FastRender.handleRoute(processFromSsr, params, req, res, next);\n    }\n\n    return _handleRoute;\n  }();\n\n  Route.prototype._processFromCache = function () {\n    function _processFromCache(pageInfo, res, next) {\n      // Here we can't simply call res.write.\n      // That's because, the HTML we've cached does not have the\n      // injected fast-render data.\n      // That's why we hijack the res.write and let FastRender to push\n      // the frData we've cached.\n      var originalWrite = res.write;\n      res.write = function () {\n        originalWrite.call(this, pageInfo.html);\n      };\n      InjectData.pushData(res, 'fast-render-data', pageInfo.frData);\n      next();\n    }\n\n    return _processFromCache;\n  }();\n\n  Route.prototype._processFromSsr = function () {\n    function _processFromSsr(params, req, res) {\n      var self = this;\n      var ssrContext = new SsrContext();\n      var routeContext = self._buildContext(req, params);\n\n      self._router.ssrContext.withValue(ssrContext, function () {\n        self._router.routeContext.withValue(routeContext, function () {\n          try {\n            // get the data for null subscriptions and add them to the\n            // ssrContext\n            var frData = InjectData.getData(res, 'fast-render-data');\n            if (frData) {\n              ssrContext.addData(frData.collectionData);\n            }\n\n            if (self.options.action) {\n              self.options.action(routeContext.params, routeContext.queryParams);\n            }\n          } catch (ex) {\n            logger.error('Error when doing SSR. path:' + req.url + ': ' + ex.message);\n            logger.error(ex.stack);\n          }\n        });\n\n        self._injectHtml(req, res, ssrContext);\n      });\n    }\n\n    return _processFromSsr;\n  }();\n\n  Route.prototype._injectHtml = function () {\n    function _injectHtml(req, res, ssrContext) {\n      var self = this;\n      var originalWrite = res.write;\n      res.write = function (data) {\n        if (typeof data === 'string') {\n          var head = ssrContext.getHead();\n          if (head && head.trim() !== '') {\n            data = data.replace('</head>', head + '\\n</head>');\n          }\n\n          var body = ssrContext.getHtml();\n          data = data.replace('<body>', '<body>\\n' + body);\n\n          if (self._router.deferScriptLoading) {\n            data = self._moveScriptsToBottom(data);\n          }\n\n          // cache the page if mentioned a timeout\n          if (self._router.pageCacheTimeout) {\n            var pageInfo = {\n              frData: InjectData.getData(res, 'fast-render-data'),\n              html: data\n            };\n            self._cachePage(req.url, req.__userId, pageInfo, self._router.pageCacheTimeout);\n          }\n        }\n\n        originalWrite.call(this, data);\n      };\n    }\n\n    return _injectHtml;\n  }();\n\n  Route.prototype._moveScriptsToBottom = function () {\n    function _moveScriptsToBottom(html) {\n      var $ = Cheerio.load(html, {\n        decodeEntities: false\n      });\n      var heads = $('head script');\n      $('body').append(heads);\n\n      // Remove empty lines caused by removing scripts\n      $('head').html($('head').html().replace(/(^[ \\t]*\\n)/gm, ''));\n\n      return $.html();\n    }\n\n    return _moveScriptsToBottom;\n  }();\n\n  Route.prototype._buildContext = function () {\n    function _buildContext(req, _params) {\n      var queryParams = _params.query;\n      // We need to remove `.query` since it's not part of our params API\n      // But we only need to remove it in our copy.\n      // We should not trigger any side effects\n      var params = _.clone(_params);\n      delete params.query;\n\n      var context = {\n        route: this,\n        path: req.url,\n        params: params,\n        queryParams: queryParams,\n        // We might change this later on. That's why it's starting with _\n        _serverRequest: req\n      };\n\n      return context;\n    }\n\n    return _buildContext;\n  }();\n\n  Route.prototype._isHtmlPage = function () {\n    function _isHtmlPage(url) {\n      var pathname = Url.parse(url).pathname;\n      var ext = pathname.split('.').slice(1).join('.');\n\n      // if there is no extention, yes that's a html page\n      if (!ext) {\n        return true;\n      }\n\n      // if this is htm or html, yes that's a html page\n      if (/^htm/.test(ext)) {\n        return true;\n      }\n\n      // if not we assume this is not as a html page\n      // this doesn't do any harm. But no SSR\n      return false;\n    }\n\n    return _isHtmlPage;\n  }();\n\n  Route.prototype._getCachedPage = function () {\n    function _getCachedPage(url, userId) {\n      var cacheInfo = { url: url, userId: userId };\n      var cacheKey = this._getCacheKey(cacheInfo);\n      var info = this._cache[cacheKey];\n      if (info) {\n        return info.data;\n      }\n    }\n\n    return _getCachedPage;\n  }();\n\n  Route.prototype._cachePage = function () {\n    function _cachePage(url, userId, data, timeout) {\n      var _this2 = this;\n\n      var cacheInfo = { url: url, userId: userId };\n      var cacheKey = this._getCacheKey(cacheInfo);\n      var existingInfo = this._cache[cacheKey];\n      if (existingInfo) {\n        // Sometimes, it's possible get this called multiple times\n        // due to race conditions. So, in that case, simply discard\n        // caching this page.\n        return;\n      }\n\n      var info = {\n        data: data,\n        timeoutHandle: setTimeout(function () {\n          delete _this2._cache[cacheKey];\n        }, timeout)\n      };\n\n      this._cache[cacheKey] = info;\n    }\n\n    return _cachePage;\n  }();\n\n  Route.prototype._getCacheKey = function () {\n    function _getCacheKey(_ref) {\n      var _ref$userId = _ref.userId;\n      var userId = _ref$userId === undefined ? '' : _ref$userId;\n      var url = _ref.url;\n\n      return userId + '::' + url;\n    }\n\n    return _getCacheKey;\n  }();\n\n  return Route;\n}(SharedRoute);","ast":null,"map":{"version":3,"sources":["/packages/kadira:flow-router-ssr/server/route.js"],"names":[],"mappings":"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","file":"/packages/kadira:flow-router-ssr/server/route.js.map","sourcesContent":["const Url = require('url');\nconst Cheerio = require('cheerio');\nconst logger = console;\n\nRoute = class extends SharedRoute {\n  constructor(router, pathDef, options, group) {\n    super(router, pathDef, options, group);\n\n    this._cache = {};\n  }\n\n  _init() {\n    const cookieParser = require('cookie-parser');\n    Picker.middleware(cookieParser());\n    // process null subscriptions with FR support\n    Picker.middleware(FastRender.handleOnAllRoutes);\n\n    const route = FlowRouter.basePath + this.pathDef;\n    Picker.route(route, this._handleRoute.bind(this));\n  }\n\n  _handleRoute(params, req, res, next) {\n    if (!this._isHtmlPage(req.url)) {\n      return next();\n    }\n\n    // This userId will be useful in the at the later on when\n    // it's time to cache the page.\n    // Normally, we can't access `Meteor.userId()` outside of a method\n    // But here, we could do it because we call `FastRender.handleOnAllRoutes`.\n    // It creates a FastRender context and assign it for the current fiber.\n    req.__userId = Meteor.userId();\n    const cachedPage = this._getCachedPage(req.url, req.__userId);\n    if (cachedPage) {\n      return this._processFromCache(cachedPage, res, next);\n    }\n\n    // Here we need to processFromSsr,\n    // but also we need to process with FastRender as well.\n    // That's why we bind processFromSsr and pass args as below.\n    // It does not get any arguments from FastRender.\n    // FastRender just trigger the following handler and do it's job\n    const processFromSsr = this._processFromSsr.bind(this, params, req, res);\n    FastRender.handleRoute(processFromSsr, params, req, res, next);\n  }\n\n  _processFromCache(pageInfo, res, next) {\n    // Here we can't simply call res.write.\n    // That's because, the HTML we've cached does not have the\n    // injected fast-render data.\n    // That's why we hijack the res.write and let FastRender to push\n    // the frData we've cached.\n    const originalWrite = res.write;\n    res.write = function() {\n      originalWrite.call(this, pageInfo.html);\n    };\n    InjectData.pushData(res, 'fast-render-data', pageInfo.frData);\n    next();\n  }\n\n  _processFromSsr(params, req, res) {\n    const self = this;\n    const ssrContext = new SsrContext();\n    const routeContext = self._buildContext(req, params);\n\n    self._router.ssrContext.withValue(ssrContext, () => {\n      self._router.routeContext.withValue(routeContext, () => {\n        try {\n          // get the data for null subscriptions and add them to the\n          // ssrContext\n          const frData = InjectData.getData(res, 'fast-render-data');\n          if (frData) {\n            ssrContext.addData(frData.collectionData);\n          }\n\n          if (self.options.action) {\n            self.options.action(routeContext.params, routeContext.queryParams);\n          }\n        } catch (ex) {\n          logger.error(`Error when doing SSR. path:${req.url}: ${ex.message}`);\n          logger.error(ex.stack);\n        }\n      });\n\n      self._injectHtml(req, res, ssrContext);\n    });\n  }\n\n  _injectHtml(req, res, ssrContext) {\n    const self = this;\n    const originalWrite = res.write;\n    res.write = function(data) {\n      if (typeof data === 'string') {\n        const head = ssrContext.getHead();\n        if (head && head.trim() !== '') {\n          data = data.replace('</head>', `${head}\\n</head>`);\n        }\n\n        const body = ssrContext.getHtml();\n        data = data.replace('<body>', `<body>\\n${body}`);\n\n        if (self._router.deferScriptLoading) {\n          data = self._moveScriptsToBottom(data);\n        }\n\n        // cache the page if mentioned a timeout\n        if (self._router.pageCacheTimeout) {\n          const pageInfo = {\n            frData: InjectData.getData(res, 'fast-render-data'),\n            html: data\n          };\n          self._cachePage(req.url, req.__userId, pageInfo, self._router.pageCacheTimeout);\n        }\n      }\n\n      originalWrite.call(this, data);\n    };\n  }\n\n  _moveScriptsToBottom(html) {\n    const $ = Cheerio.load(html, {\n      decodeEntities: false\n    });\n    const heads = $('head script');\n    $('body').append(heads);\n\n    // Remove empty lines caused by removing scripts\n    $('head').html($('head').html().replace(/(^[ \\t]*\\n)/gm, ''));\n\n    return $.html();\n  }\n\n  _buildContext(req, _params) {\n    const queryParams = _params.query;\n    // We need to remove `.query` since it's not part of our params API\n    // But we only need to remove it in our copy.\n    // We should not trigger any side effects\n    const params = _.clone(_params);\n    delete params.query;\n\n    const context = {\n      route: this,\n      path: req.url,\n      params,\n      queryParams,\n      // We might change this later on. That's why it's starting with _\n      _serverRequest: req\n    };\n\n    return context;\n  }\n\n  _isHtmlPage(url) {\n    const pathname = Url.parse(url).pathname;\n    const ext = pathname.split('.').slice(1).join('.');\n\n    // if there is no extention, yes that's a html page\n    if (!ext) {\n      return true;\n    }\n\n    // if this is htm or html, yes that's a html page\n    if (/^htm/.test(ext)) {\n      return true;\n    }\n\n    // if not we assume this is not as a html page\n    // this doesn't do any harm. But no SSR\n    return false;\n  }\n\n  _getCachedPage(url, userId) {\n    const cacheInfo = {url, userId};\n    const cacheKey = this._getCacheKey(cacheInfo);\n    const info = this._cache[cacheKey];\n    if (info) {\n      return info.data;\n    }\n  }\n\n  _cachePage(url, userId, data, timeout) {\n    const cacheInfo = {url, userId};\n    const cacheKey = this._getCacheKey(cacheInfo);\n    const existingInfo = this._cache[cacheKey];\n    if (existingInfo) {\n      // Sometimes, it's possible get this called multiple times\n      // due to race conditions. So, in that case, simply discard\n      // caching this page.\n      return;\n    }\n\n    const info = {\n      data: data,\n      timeoutHandle: setTimeout(() => {\n        delete this._cache[cacheKey];\n      }, timeout)\n    };\n\n    this._cache[cacheKey] = info;\n  }\n\n  _getCacheKey({userId = '', url}) {\n    return `${userId}::${url}`;\n  }\n};\n"]},"hash":"7b84e0fd833c4ed5b26e65b9ea69b4a27f6c6845"}
