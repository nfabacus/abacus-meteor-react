{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"qs","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Qs"}]},{"source":"path-to-regexp","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"PathToRegexp"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/kadira:flow-router-ssr/lib/router.js","filenameRelative":"/packages/kadira:flow-router-ssr/lib/router.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/kadira:flow-router-ssr/lib/router.js.map","sourceFileName":"/packages/kadira:flow-router-ssr/lib/router.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"router"},"ignored":false,"code":"var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _qs = require('qs');\n\nvar _qs2 = _interopRequireDefault(_qs);\n\nvar _pathToRegexp = require('path-to-regexp');\n\nvar _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nSharedRouter = function () {\n  function SharedRouter() {\n    (0, _classCallCheck3['default'])(this, SharedRouter);\n\n    this._routes = [];\n    this._routesMap = {};\n\n    // holds onRoute callbacks\n    this._onRouteCallbacks = [];\n\n    this.env = {};\n    this.env.trailingSlash = new Meteor.EnvironmentVariable();\n  }\n\n  SharedRouter.prototype.route = function () {\n    function route(pathDef, options, group) {\n      if (!/^\\/.*/.test(pathDef)) {\n        var message = \"route's path must start with '/'\";\n        throw new Error(message);\n      }\n\n      options = options || {};\n\n      var currentRoute = new Route(this, pathDef, options, group);\n      currentRoute._init();\n\n      this._routes.push(currentRoute);\n\n      if (options.name) {\n        this._routesMap[options.name] = currentRoute;\n      }\n\n      this._triggerRouteRegister(currentRoute);\n\n      return currentRoute;\n    }\n\n    return route;\n  }();\n\n  // XXX this function needs to be cleaned up if possible by removing `if (this.isServer)`\n  // and `if (this.isClient)` if possible\n\n\n  SharedRouter.prototype.path = function () {\n    function path(pathDef) {\n      var fields = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n      var queryParams = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      if (this._routesMap[pathDef]) {\n        pathDef = this._routesMap[pathDef].path;\n      }\n\n      var newPath = '';\n\n      // Prefix the path with the router global prefix\n      if (this._basePath) {\n        newPath += '/' + this._basePath + '/';\n      }\n\n      // Encode query params\n      queryParams = this._encodeValues(queryParams);\n\n      var toPath = _pathToRegexp2['default'].compile(pathDef);\n      newPath += toPath(fields);\n\n      // If we have one optional parameter in path definition e.g.\n      // /:category?\n      // and the parameter isn't present, path will be an empty string.\n      // We have this check as a value for path is required by e.g. FlowRouter.go()\n      if (!newPath) {\n        newPath = '/';\n      }\n\n      // Replace multiple slashes with single slash\n      newPath = newPath.replace(/\\/\\/+/g, '/');\n\n      // remove trailing slash\n      // but keep the root slash if it's the only one\n      newPath = newPath.match(/^\\/{1}$/) ? newPath : newPath.replace(/\\/$/, '');\n\n      // explictly asked to add a trailing slash\n      if (this.env.trailingSlash.get() && _.last(newPath) !== '/') {\n        newPath += '/';\n      }\n\n      var strQueryParams = _qs2['default'].stringify(queryParams || {});\n\n      if (strQueryParams) {\n        newPath += '?' + strQueryParams;\n      }\n\n      return newPath;\n    }\n\n    return path;\n  }();\n\n  SharedRouter.prototype.go = function () {\n    function go() {\n      // client only\n    }\n\n    return go;\n  }();\n\n  SharedRouter.prototype.watchPathChange = function () {\n    function watchPathChange() {\n      // client only\n    }\n\n    return watchPathChange;\n  }();\n\n  SharedRouter.prototype.group = function () {\n    function group(options) {\n      return new Group(this, options);\n    }\n\n    return group;\n  }();\n\n  SharedRouter.prototype.url = function () {\n    function url() {\n      // We need to remove the leading base path, or \"/\", as it will be inserted\n      // automatically by `Meteor.absoluteUrl` as documented in:\n      // http://docs.meteor.com/#/full/meteor_absoluteurl\n      var completePath = this.path.apply(this, arguments);\n      var basePath = this._basePath || '/';\n      var pathWithoutBase = completePath.replace(RegExp('^' + basePath), '');\n      return Meteor.absoluteUrl(pathWithoutBase);\n    }\n\n    return url;\n  }();\n\n  // For client:\n  // .current is not reactive on the client\n  // This is by design. use .getParam() instead\n  // If you really need to watch the path change, use .watchPathChange()\n\n\n  SharedRouter.prototype.current = function () {\n    function current() {\n      // We can't trust outside, that's why we clone this\n      // Anyway, we can't clone the whole object since it has non-jsonable values\n      // That's why we clone what's really needed.\n      var context = _.clone(this._getCurrentRouteContext());\n\n      context.queryParams = EJSON.clone(context.queryParams);\n      context.params = EJSON.clone(context.params);\n\n      return context;\n    }\n\n    return current;\n  }();\n\n  SharedRouter.prototype.onRouteRegister = function () {\n    function onRouteRegister(cb) {\n      this._onRouteCallbacks.push(cb);\n    }\n\n    return onRouteRegister;\n  }();\n\n  SharedRouter.prototype._encodeValues = function () {\n    function _encodeValues(obj) {\n      var newObj = {};\n      Object.keys(obj).forEach(function (key) {\n        var value = obj[key];\n        newObj[key] = typeof value !== 'undefined' ? encodeURIComponent(value) : value;\n      });\n\n      return newObj;\n    }\n\n    return _encodeValues;\n  }();\n\n  SharedRouter.prototype._triggerRouteRegister = function () {\n    function _triggerRouteRegister(currentRoute) {\n      // We should only need to send a safe set of fields on the route\n      // object.\n      // This is not to hide what's inside the route object, but to show\n      // these are the public APIs\n      var routePublicApi = _.pick(currentRoute, 'name', 'pathDef', 'path');\n      var omittingOptionFields = ['triggersEnter', 'triggersExit', 'name', 'action'];\n      routePublicApi.options = _.omit(currentRoute.options, omittingOptionFields);\n\n      this._onRouteCallbacks.forEach(function (cb) {\n        cb(routePublicApi);\n      });\n    }\n\n    return _triggerRouteRegister;\n  }();\n\n  SharedRouter.prototype._getCurrentRouteContext = function () {\n    function _getCurrentRouteContext() {\n      throw new Error('Not implemented');\n    }\n\n    return _getCurrentRouteContext;\n  }();\n\n  SharedRouter.prototype._init = function () {\n    function _init() {\n      throw new Error('Not implemented');\n    }\n\n    return _init;\n  }();\n\n  SharedRouter.prototype.withTrailingSlash = function () {\n    function withTrailingSlash(fn) {\n      return this.env.trailingSlash.withValue(true, fn);\n    }\n\n    return withTrailingSlash;\n  }();\n\n  return SharedRouter;\n}();","ast":null,"map":{"version":3,"sources":["/packages/kadira:flow-router-ssr/lib/router.js"],"names":[],"mappings":"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","file":"/packages/kadira:flow-router-ssr/lib/router.js.map","sourcesContent":["import Qs from 'qs';\nimport PathToRegexp from 'path-to-regexp';\n\nSharedRouter = class {\n  constructor() {\n    this._routes = [];\n    this._routesMap = {};\n\n    // holds onRoute callbacks\n    this._onRouteCallbacks = [];\n\n    this.env = {};\n    this.env.trailingSlash = new Meteor.EnvironmentVariable();\n  }\n\n  route(pathDef, options, group) {\n    if (!/^\\/.*/.test(pathDef)) {\n      const message = \"route's path must start with '/'\";\n      throw new Error(message);\n    }\n\n    options = options || {};\n\n    const currentRoute = new Route(this, pathDef, options, group);\n    currentRoute._init();\n\n    this._routes.push(currentRoute);\n\n\n    if (options.name) {\n      this._routesMap[options.name] = currentRoute;\n    }\n\n    this._triggerRouteRegister(currentRoute);\n\n    return currentRoute;\n  }\n\n  // XXX this function needs to be cleaned up if possible by removing `if (this.isServer)`\n  // and `if (this.isClient)` if possible\n  path(pathDef, fields = {}, queryParams = {}) {\n    if (this._routesMap[pathDef]) {\n      pathDef = this._routesMap[pathDef].path;\n    }\n\n    let newPath = '';\n\n    // Prefix the path with the router global prefix\n    if (this._basePath) {\n      newPath += `/${this._basePath}/`;\n    }\n\n    // Encode query params\n    queryParams = this._encodeValues(queryParams);\n\n    const toPath = PathToRegexp.compile(pathDef);\n    newPath += toPath(fields);\n\n    // If we have one optional parameter in path definition e.g.\n    // /:category?\n    // and the parameter isn't present, path will be an empty string.\n    // We have this check as a value for path is required by e.g. FlowRouter.go()\n    if (!newPath) {\n      newPath = '/';\n    }\n\n    // Replace multiple slashes with single slash\n    newPath = newPath.replace(/\\/\\/+/g, '/');\n\n    // remove trailing slash\n    // but keep the root slash if it's the only one\n    newPath = newPath.match(/^\\/{1}$/) ? newPath : newPath.replace(/\\/$/, '');\n\n    // explictly asked to add a trailing slash\n    if (this.env.trailingSlash.get() && _.last(newPath) !== '/') {\n      newPath += '/';\n    }\n\n    const strQueryParams = Qs.stringify(queryParams || {});\n\n    if (strQueryParams) {\n      newPath += `?${strQueryParams}`;\n    }\n\n    return newPath;\n  }\n\n  go() {\n    // client only\n  }\n\n  watchPathChange() {\n    // client only\n  }\n\n  group(options) {\n    return new Group(this, options);\n  }\n\n  url(...args) {\n    // We need to remove the leading base path, or \"/\", as it will be inserted\n    // automatically by `Meteor.absoluteUrl` as documented in:\n    // http://docs.meteor.com/#/full/meteor_absoluteurl\n    const completePath = this.path(...args);\n    const basePath = this._basePath || '/';\n    const pathWithoutBase = completePath.replace(RegExp(`^${basePath}`), '');\n    return Meteor.absoluteUrl(pathWithoutBase);\n  }\n\n  // For client:\n  // .current is not reactive on the client\n  // This is by design. use .getParam() instead\n  // If you really need to watch the path change, use .watchPathChange()\n  current() {\n    // We can't trust outside, that's why we clone this\n    // Anyway, we can't clone the whole object since it has non-jsonable values\n    // That's why we clone what's really needed.\n    const context = _.clone(this._getCurrentRouteContext());\n\n    context.queryParams = EJSON.clone(context.queryParams);\n    context.params = EJSON.clone(context.params);\n\n    return context;\n  }\n\n  onRouteRegister(cb) {\n    this._onRouteCallbacks.push(cb);\n  }\n\n  _encodeValues(obj) {\n    const newObj = {};\n    Object.keys(obj).forEach(key => {\n      const value = obj[key];\n      newObj[key] = typeof value !== 'undefined' ? encodeURIComponent(value) : value;\n    });\n\n    return newObj;\n  }\n\n  _triggerRouteRegister(currentRoute) {\n    // We should only need to send a safe set of fields on the route\n    // object.\n    // This is not to hide what's inside the route object, but to show\n    // these are the public APIs\n    const routePublicApi = _.pick(currentRoute, 'name', 'pathDef', 'path');\n    const omittingOptionFields = [\n      'triggersEnter', 'triggersExit', 'name', 'action'\n    ];\n    routePublicApi.options = _.omit(currentRoute.options, omittingOptionFields);\n\n    this._onRouteCallbacks.forEach((cb) => {\n      cb(routePublicApi);\n    });\n  }\n\n  _getCurrentRouteContext() {\n    throw new Error('Not implemented');\n  }\n\n  _init() {\n    throw new Error('Not implemented');\n  }\n\n  withTrailingSlash(fn) {\n    return this.env.trailingSlash.withValue(true, fn);\n  }\n};\n"]},"hash":"69955fbd597fc6ae716a84d6b07b2517988a8b59"}
