{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/kadira:flow-router-ssr/test/_engine/describe.js","filenameRelative":"/packages/kadira:flow-router-ssr/test/_engine/describe.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/kadira:flow-router-ssr/test/_engine/describe.js.map","sourceFileName":"/packages/kadira:flow-router-ssr/test/_engine/describe.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"describe"},"ignored":false,"code":"/**\n * Holds a list of describe descriptions as we traverse the\n * describe tree.\n * @type {Array}\n */\nvar lst = [];\n\n/**\n * Root describe statement, initializes a test suite.\n * @param description suite description.\n * @param fn function to be executed.\n */\ndescribe = function (_describe) {\n  function describe(_x, _x2) {\n    return _describe.apply(this, arguments);\n  }\n\n  describe.toString = function () {\n    return _describe.toString();\n  };\n\n  return describe;\n}(function (description, fn) {\n  var _this = this;\n\n  lst.push(description);\n\n  var steps = {\n    description: lst.slice(0),\n    it: [],\n    before: null,\n    beforeEach: null,\n    after: null,\n    afterEach: null\n  };\n\n  this.context = _.bind(describe, this);\n\n  this.before = function (bfn) {\n    steps.before = _.bind(bfn, _this);\n  };\n\n  this.beforeEach = function (befn) {\n    steps.beforeEach = _.bind(befn, _this);\n  };\n\n  this.after = function (afn) {\n    steps.after = _.bind(afn, _this);\n  };\n\n  this.afterEach = function (aefn) {\n    steps.afterEach = _.bind(aefn, _this);\n  };\n\n  this.it = function (str, itfn) {\n    steps.it.push({\n      desc: str,\n      fn: _.bind(itfn, _this)\n    });\n  };\n\n  _.bind(fn, this)();\n\n  _.bind(execute, this)(steps);\n\n  lst.pop();\n});\n\n/**\n * Executes the defined steps in the proper order.\n * @param steps description object.\n */\nvar execute = function execute(steps) {\n\n  // Create a test for before\n  hookFor(steps, 'before');\n\n  // Create tests for beforeEach, it and afterEach\n\n  var _loop = function _loop(itObj) {\n    hookFor(steps, 'beforeEach', itObj.desc);\n\n    if (itObj.fn.length > 0) {\n      Tinytest.addAsync(prepDesc(steps.description, itObj.desc), function (test, done) {\n        tryTest(test, _.bind(itObj.fn, {}, tryDone(test, done)), done);\n      });\n    } else {\n      Tinytest.add(prepDesc(steps.description, itObj.desc), function (test) {\n        tryTest(test, itObj.fn);\n      });\n    }\n\n    hookFor(steps, 'afterEach', itObj.desc);\n  };\n\n  for (var _iterator = steps.it, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var itObj = _ref;\n\n    _loop(itObj);\n  }\n  // Create a test for after\n  hookFor(steps, 'after');\n};\n\n/**\n * Define the given test hook.\n * @param steps Object that holds the available hooks and data.\n * @param when The name of the hook to be called.\n * @param append optional test to append to the test description.\n */\nvar hookFor = function hookFor(steps, when, append) {\n  if (steps[when] !== null) {\n    var str = when;\n    if (append) {\n      str = when + ' (' + append + ')';\n    }\n    if (steps[when].length > 0) {\n      Tinytest.addAsync(prepDesc(steps.description, str), function (test, done) {\n        tryTest(test, _.bind(steps[when], {}, tryDone(test, done)), done);\n      });\n    } else {\n      Tinytest.add(prepDesc(steps.description, str), function (test) {\n        tryTest(test, steps[when]);\n      });\n    }\n  }\n};\n\n/**\n * Prepares a tinytest description by joining the describe, context, and it description with ' - '.\n * @param lst ancestors descriptions.\n * @param desc current description.\n * @returns {string} joined description.\n */\nvar prepDesc = function prepDesc(lst, desc) {\n  return lst.concat(desc).join(' - ');\n};\n\n/**\n * Wraps a synchronous tests with try/catch statements, and reports a failed test on an AssertError.\n * @param test Tinytest test function.\n * @param fn Function being wrapped.\n */\nvar tryTest = function tryTest(test, fn, done) {\n  try {\n    fn();\n  } catch (e) {\n    if (e.constructor.name === 'AssertionError') {\n      test.equal(e.actual, e.expected, e.message);\n    } else {\n      test.equal(e.toString(), undefined);\n    }\n    if (done) {\n      done();\n    }\n  }\n};\n\n/**\n * Create a function to replace Tinytest's \"onComplete\" callback, so we report the exception as a failed test.\n * @param test Tinytest test function.\n * @param done Tinytest onComplete callback.\n * @returns {Function} a Mocha(ish) compatible done function.\n */\nvar tryDone = function tryDone(test, done) {\n  return function (assertError) {\n    if (assertError) {\n      if (assertError.constructor.name === 'AssertionError') {\n        test.equal(assertError.actual, assertError.expected, assertError.message);\n      } else {\n        test.equal(assertError.toString(), undefined);\n      }\n    }\n    done();\n  };\n};","ast":null,"map":{"version":3,"sources":["/packages/kadira:flow-router-ssr/test/_engine/describe.js"],"names":[],"mappings":"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","file":"/packages/kadira:flow-router-ssr/test/_engine/describe.js.map","sourcesContent":["/**\n * Holds a list of describe descriptions as we traverse the\n * describe tree.\n * @type {Array}\n */\nlet lst = [];\n\n/**\n * Root describe statement, initializes a test suite.\n * @param description suite description.\n * @param fn function to be executed.\n */\ndescribe = function (description, fn) {\n  lst.push(description);\n\n  let steps = {\n    description: lst.slice(0),\n    it: [],\n    before: null,\n    beforeEach: null,\n    after: null,\n    afterEach: null\n  };\n\n  this.context = _.bind(describe, this);\n\n  this.before =  (bfn) => {\n    steps.before = _.bind(bfn, this);\n  };\n\n  this.beforeEach =  (befn) => {\n    steps.beforeEach = _.bind(befn, this);\n  };\n\n  this.after = (afn) => {\n    steps.after = _.bind(afn, this);\n  };\n\n  this.afterEach =  (aefn) => {\n    steps.afterEach = _.bind(aefn, this);\n  };\n\n  this.it =  (str, itfn) => {\n    steps.it.push({\n      desc: str,\n      fn: _.bind(itfn, this)\n    });\n  };\n\n  _.bind(fn, this)();\n\n  _.bind(execute, this)(steps);\n\n  lst.pop();\n};\n\n/**\n * Executes the defined steps in the proper order.\n * @param steps description object.\n */\nlet execute = function(steps) {\n\n  // Create a test for before\n  hookFor(steps, 'before');\n\n  // Create tests for beforeEach, it and afterEach\n  for (let itObj of steps.it) {\n    hookFor(steps, 'beforeEach', itObj.desc);\n\n    if (itObj.fn.length > 0) {\n      Tinytest.addAsync(prepDesc(steps.description, itObj.desc), (test, done) => {\n        tryTest(test, _.bind(itObj.fn, {}, tryDone(test, done)), done);\n      })\n    } else {\n      Tinytest.add(prepDesc(steps.description, itObj.desc), (test) => {\n        tryTest(test, itObj.fn);\n      });\n    }\n\n    hookFor(steps, 'afterEach', itObj.desc);\n  }\n  // Create a test for after\n  hookFor(steps, 'after');\n};\n\n/**\n * Define the given test hook.\n * @param steps Object that holds the available hooks and data.\n * @param when The name of the hook to be called.\n * @param append optional test to append to the test description.\n */\nlet hookFor = function (steps, when, append) {\n  if (steps[when] !== null) {\n    let str = when;\n    if (append) {\n      str = `${when} (${append})`;\n    }\n    if (steps[when].length > 0) {\n      Tinytest.addAsync(prepDesc(steps.description, str), (test, done) => {\n        tryTest(test, _.bind(steps[when], {}, tryDone(test, done)), done);\n      });\n    } else {\n      Tinytest.add(prepDesc(steps.description, str), (test) => {\n        tryTest(test, steps[when]);\n      });\n    }\n  }\n};\n\n/**\n * Prepares a tinytest description by joining the describe, context, and it description with ' - '.\n * @param lst ancestors descriptions.\n * @param desc current description.\n * @returns {string} joined description.\n */\nlet prepDesc = function(lst, desc) {\n  return lst.concat(desc).join(' - ');\n};\n\n/**\n * Wraps a synchronous tests with try/catch statements, and reports a failed test on an AssertError.\n * @param test Tinytest test function.\n * @param fn Function being wrapped.\n */\nlet tryTest = function(test, fn, done) {\n  try {\n    fn();\n  } catch (e) {\n    if (e.constructor.name === 'AssertionError') {\n      test.equal(e.actual, e.expected, e.message);\n    } else {\n      test.equal(e.toString(), undefined);\n    }\n    if (done) {\n      done();\n    }\n  }\n};\n\n/**\n * Create a function to replace Tinytest's \"onComplete\" callback, so we report the exception as a failed test.\n * @param test Tinytest test function.\n * @param done Tinytest onComplete callback.\n * @returns {Function} a Mocha(ish) compatible done function.\n */\nlet tryDone = function(test, done) {\n  return function(assertError) {\n    if (assertError) {\n      if (assertError.constructor.name === 'AssertionError') {\n        test.equal(assertError.actual, assertError.expected, assertError.message);\n      } else {\n        test.equal(assertError.toString(), undefined);\n      }\n    }\n    done();\n  }\n};\n"]},"hash":"d39f6b243c0aeebdd80f36b115337aca8b402a03"}
