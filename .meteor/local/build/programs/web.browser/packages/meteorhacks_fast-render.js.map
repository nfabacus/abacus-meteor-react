{"version":3,"sources":["meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/utils.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/id_tools.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/fast_render.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/debugger.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/ddp_update.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/auth.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/client/boot.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA,sH","file":"/packages/meteorhacks_fast-render.js","sourcesContent":["AddedToChanged = function(localCopy, added) {\n  added.msg = \"changed\";\n  added.cleared = [];\n  added.fields = added.fields || {};\n\n  _.each(localCopy, function(value, key) {\n    if(key != '_id') {\n      if(typeof added.fields[key] == \"undefined\") {\n        added.cleared.push(key);\n      }\n    }\n  });\n};\n\nApplyDDP = function(existing, message) {\n  var newDoc = (!existing)? {}: _.clone(existing);\n  if(message.msg == 'added') {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n  } else if(message.msg == \"changed\") {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n    _.each(message.cleared, function(key) {\n      delete newDoc[key];\n    });\n  } else if(message.msg == \"removed\") {\n    newDoc = null;\n  }\n\n  return newDoc;\n};\n\n// source: https://gist.github.com/kurtmilam/1868955\n//  modified a bit to not to expose this as an _ api\nDeepExtend = function deepExtend (obj) {\n  var parentRE = /#{\\s*?_\\s*?}/,\n      slice = Array.prototype.slice,\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  _.each(slice.call(arguments, 1), function(source) {\n    for (var prop in source) {\n      if (hasOwnProperty.call(source, prop)) {\n        if (_.isNull(obj[prop]) || _.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {\n          obj[prop] = source[prop];\n        }\n        else if (_.isString(source[prop]) && parentRE.test(source[prop])) {\n          if (_.isString(obj[prop])) {\n            obj[prop] = source[prop].replace(parentRE, obj[prop]);\n          }\n        }\n        else if (_.isArray(obj[prop]) || _.isArray(source[prop])){\n          if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){\n            throw 'Error: Trying to combine an array with a non-array (' + prop + ')';\n          } else {\n            obj[prop] = _.reject(DeepExtend(obj[prop], source[prop]), function (item) { return _.isNull(item);});\n          }\n        }\n        else if (_.isObject(obj[prop]) || _.isObject(source[prop])){\n          if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){\n            throw 'Error: Trying to combine an object with a non-object (' + prop + ')';\n          } else {\n            obj[prop] = DeepExtend(obj[prop], source[prop]);\n          }\n        } else {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n  });\n  return obj;\n};","IDTools = {};\nIDTools.idParse = LocalCollection._idParse;\nIDTools.idStringify = LocalCollection._idStringify;\nIDTools.ObjectID = LocalCollection._ObjectID\n\n// To support Meteor 1.2\nif(Package['mongo-id']) {\n  var MongoID = Package['mongo-id'].MongoID;\n  IDTools.idParse = MongoID.idParse;\n  IDTools.idStringify = MongoID.idStringify;\n  IDTools.ObjectID = MongoID.ObjectID;\n}","FastRender = {};\nFastRender.enabled = typeof __fast_render_config != 'undefined';\nFastRender._dataReceived = false;\nFastRender._revertedBackToOriginal = false;\nFastRender._blockDDP = Meteor._localStorage.getItem('__frblockddp') != undefined;\nif(FastRender._blockDDP) {\n  console.log(\"FastRender is blocking DDP messages. apply 'FastRender.debugger.unblockDDP()' to unblock again.\");\n}\n\nFastRender._disable = Meteor._localStorage.getItem('__frdisable') != undefined;\nif(FastRender._disable) {\n  console.log(\"FastRender is disabled. apply 'FastRender.debugger.enableFR()' to enable it back.\")\n}\n\n// This allow us to apply DDP message even if Meteor block accepting messages\n//  When doing initial login, Meteor sends an login message\n//  Then it'll block the accpeting DDP messages from server\n//  This is the cure\nFastRender.injectDdpMessage = function(conn, message) {\n  FastRender[\"debugger\"].log('injecting ddp message:', message);\n  if (conn._bufferedWrites) {\n    // New with meteor/meteor#5680\n    // If the livedata connection supports buffered writes,\n    // we don't need check if we're in delay before injecting.\n    conn._livedata_data(message);\n  } else {\n    var originalWait = conn._waitingForQuiescence;\n    conn._waitingForQuiescence = function() {return false};\n    conn._livedata_data(message);\n    conn._waitingForQuiescence = originalWait;\n  }\n};\n\nFastRender.init = function(payload) {\n  if(FastRender._disable) return;\n\n  FastRender._securityCheck(payload);\n\n  FastRender._subscriptions = (payload && payload.subscriptions) || {};\n  FastRender._subscriptionIdMap = {};\n  FastRender._dataReceived = true;\n  FastRender._payload = payload;\n\n  // merging data from different subscriptions\n  //  yes, this is a minimal mergeBox on the client\n  var allData = {};\n  if (payload) {\n    _.each(payload.collectionData, function(subData, collName) {\n      if(!allData[collName]) {\n        allData[collName] = {};\n      }\n      collData = allData[collName];\n\n      subData.forEach(function(dataSet) {\n        dataSet.forEach(function(item) {\n          if(!collData[item._id]) {\n            collData[item._id] = item;\n          } else {\n            DeepExtend(collData[item._id], item);\n          }\n        });\n      });\n    });\n  }\n\n  var connection = Meteor.connection;\n\n  _.each(allData, function(collData, collName) {\n    _.each(collData, function(item, id) {\n      var id = IDTools.idStringify(item._id);\n      delete item._id;\n\n      var ddpMessage = {\n        msg: 'added',\n        collection: collName,\n        id: id,\n        fields: item,\n        frGen: true\n      };\n\n      FastRender.injectDdpMessage(connection, ddpMessage);\n    });\n  });\n\n  // If the connection supports buffered DDP writes, then flush now.\n  if (connection._flushBufferedWrites) connection._flushBufferedWrites();\n\n  // let Meteor know, user login process has been completed\n  if(typeof Accounts != 'undefined') {\n    Accounts._setLoggingIn(false);\n  }\n};\n\nFastRender._securityCheck = function(payload) {\n  if(payload && payload.loginToken) {\n    var localStorageLoginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n    if(localStorageLoginToken != payload.loginToken) {\n      throw new Error(\"seems like cookie tossing is happening. visit here: http://git.io/q4IRHQ\");\n    }\n  }\n};","FastRender[\"debugger\"] = {};\nFastRender[\"debugger\"]._logs = [];\nFastRender[\"debugger\"].log = function function_name(message/*, args..*/) {\n  if(\n    typeof console != 'undefined' &&\n    typeof Meteor._localStorage != 'undefined' && \n    Meteor._localStorage.getItem('__frlog') == \"1\") \n  {\n    FastRender[\"debugger\"]._logs.push(arguments);\n    arguments[0] = \"FR: \" + arguments[0];\n    console.log.apply(console, arguments);\n  }\n}\n\nFastRender[\"debugger\"].showLogs = function() {\n  Meteor._localStorage.setItem('__frlog', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].hideLogs = function() {\n  Meteor._localStorage.removeItem('__frlog');\n  location.reload();\n};\n\nFastRender[\"debugger\"].getLogs = function() {\n  return FastRender[\"debugger\"]._logs;\n};\n\nFastRender[\"debugger\"].getLogsJSON = function() {\n  return JSON.stringify(FastRender[\"debugger\"]._logs);\n};\n\nFastRender[\"debugger\"].blockDDP = function() {\n  Meteor._localStorage.setItem('__frblockddp', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].unblockDDP = function() {\n  Meteor._localStorage.removeItem('__frblockddp');\n  location.reload();\n};\n\nFastRender[\"debugger\"].disableFR = function() {\n  Meteor._localStorage.setItem('__frdisable', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].enableFR = function() {\n  Meteor._localStorage.removeItem('__frdisable');\n  location.reload();\n};\n\nFastRender[\"debugger\"].getPayload = function() {\n  return FastRender._payload;\n};\n\nFastRender[\"debugger\"].getPayloadJSON = function() {\n  return JSON.stringify(FastRender._payload);\n};\n","var reconnecting = false;\n\nvar originalLivedataData = Meteor.connection._livedata_data;\nMeteor.connection._livedata_data = function(msg) {\n  if(FastRender._blockDDP && !msg.frGen) {\n    FastRender[\"debugger\"].log('blocking incoming ddp', msg);\n    return;\n  };\n  // fast-render adds data manually while initializing\n  // But when the server sends actual data via DDP, it also tries to add\n  // Then we need to detect that and alter\n  //\n  // But we don't need to interfer with Meteor's simulation process\n  // That's why we are checking for serverDocs and ignore manual handling\n  //\n  // We don't need this logic after our special handling reverted back to\n  // original. But we can't detect when null publications completed or not\n  // That's why we need keep this logic\n  //\n  // It's okay to ignore this logic after sometime, but not sure when exactly\n\n  if(msg.msg == 'added') {\n    var id = IDTools.idParse(msg.id);\n    var serverDoc = this._getServerDoc(msg.collection, id);\n    \n    if(!reconnecting && !serverDoc) {\n      var localCollection = this._mongo_livedata_collections[msg.collection];\n      var pendingStoreUpdates = this._updatesForUnknownStores[msg.collection];\n      if(localCollection) {\n        var existingDoc = localCollection.findOne(id);\n        if(existingDoc) {\n          FastRender[\"debugger\"].log('re writing DDP for:', msg);\n          AddedToChanged(existingDoc, msg);\n        }\n      } else if(pendingStoreUpdates) {\n        var mergedDoc = null;\n        var existingDocs = _.filter(pendingStoreUpdates, function(doc) {\n          return doc.id == msg.id;\n        });\n\n        _.each(existingDocs, function(cachedMsg) {\n          mergedDoc = ApplyDDP(mergedDoc, cachedMsg);\n        });\n        \n        if(mergedDoc) {\n          FastRender[\"debugger\"].log('re writing DDP for:', msg);\n          AddedToChanged(mergedDoc, msg);\n        }\n      }\n    }\n  }\n\n  // if we've completed our tasks, no need of special handling\n  if(!FastRender._revertedBackToOriginal && FastRender._dataReceived) {\n\n    // This will take care of cleaning special subscription handling\n    // after the actual subscription comes out\n    if(msg.msg == 'ready' && !msg.frGen && FastRender._subscriptions) {\n      msg.subs.forEach(function(subId) {\n        var subscription = FastRender._subscriptionIdMap[subId];\n        if(subscription) {\n          FastRender[\"debugger\"].log('actual subscription completed:', subscription, subId);\n          // we don't need to handle specially after this\n          var paramsKeyMap = FastRender._subscriptions[subscription.name] || {};\n          delete paramsKeyMap[subscription.paramsKey];\n          if(EJSON.equals(FastRender._subscriptions[subscription.name], {})) {\n            delete FastRender._subscriptions[subscription.name];\n          }\n          delete FastRender._subscriptionIdMap[subId];\n        }\n      });\n    }\n\n    // if all the subscriptions have been processed,\n    // there is no need to keep hijacking\n    if(EJSON.equals(FastRender._subscriptions, {})) {\n      FastRender[\"debugger\"].log('fast rendering completed!');\n      FastRender._revertedBackToOriginal = true;\n    }\n  }\n\n  return originalLivedataData.call(this, msg);\n};\n\nvar originalSend = Meteor.connection._send;\nMeteor.connection._send = function(msg) {\n  // if looking for connect again to the server, we must need to revert back to\n  // original to prevent some weird DDP issues\n  //  normally it is already reverted, but user may added subscriptions\n  //  in server, which are not subscribed from the client\n  if(msg.msg == 'connect' && msg.session != undefined) {\n    FastRender._revertedBackToOriginal = true;\n    reconnecting = true;\n  }\n\n  var self = this;\n\n  // if we've completed our tasks, no need of special handling\n  if(!FastRender._revertedBackToOriginal && FastRender._dataReceived) {\n    var paramsKey = EJSON.stringify(msg.params);\n    var canSendFakeReady =\n      msg.msg == 'sub' &&\n      FastRender._subscriptions[msg.name] &&\n      FastRender._subscriptions[msg.name][paramsKey];\n\n    FastRender[\"debugger\"].log('new subscription:', msg.name);\n    if(canSendFakeReady) {\n      FastRender[\"debugger\"].log('sending fake ready for sub:', msg.name);\n      FastRender.injectDdpMessage(self, {msg:\"ready\",subs:[msg.id], frGen: true});\n      // add the messageId to be handled later\n      FastRender._subscriptionIdMap[msg.id] = {\n        name: msg.name,\n        paramsKey: paramsKey\n      };\n    }\n  }\n\n  return originalSend.call(this, msg);\n};\n","// getting tokens for the first time\n//  Meteor calls Meteor._localStorage.setItem() on the boot\n//  But we can do it ourselves also with this\nMeteor.startup(function() {\n  resetToken();\n});\n\n// override Meteor._localStorage methods and resetToken accordingly\nvar originalSetItem = Meteor._localStorage.setItem;\nMeteor._localStorage.setItem = function(key, value) {\n  if(key == 'Meteor.loginToken') {\n    Meteor.defer(resetToken);\n  }\n  originalSetItem.call(Meteor._localStorage, key, value);\n};\n\nvar originalRemoveItem = Meteor._localStorage.removeItem;\nMeteor._localStorage.removeItem = function(key) {\n  if(key == 'Meteor.loginToken') {\n    Meteor.defer(resetToken);\n  }\n  originalRemoveItem.call(Meteor._localStorage, key);\n}\n\nfunction resetToken() {\n  var loginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n  var loginTokenExpires = new Date(Meteor._localStorage.getItem('Meteor.loginTokenExpires'));\n\n  if(loginToken) {\n    setToken(loginToken, loginTokenExpires);\n  } else {\n    setToken(null, -1);\n  }\n}\n\nfunction setToken(loginToken, expires) {\n  Cookie.set('meteor_login_token', loginToken, {\n    path: '/',\n    expires: expires\n  });\n}","InjectData.getData('fast-render-data', function(payload) {\n  FastRender.init(payload);\n});"]}